{"version":3,"file":"setBuildWorker.js","mappings":"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","sources":["webpack://MHRDamage/./srcfiles/setBuildWorker2.js"],"sourcesContent":["function addSkills(innateSkills, remainingSkillsSorted, thisRun, costsUsed, skillsLimit, maxPoints) {\n  costLoop: for (let [skillCost, timesUsed] of Object.entries(costsUsed)) {\n    // loops through the used remaining skills for the current costs used\n    for (const skillName of innateSkills.values()) {\n      // tests if innateSkills are available\n      if (!remainingSkillsSorted[skillCost][skillName]) continue;\n      let usablePoints = Math.min(timesUsed, remainingSkillsSorted[skillCost][skillName]);\n      thisRun[0] += +skillCost * usablePoints;\n      maxPoints -= usablePoints;\n      timesUsed -= usablePoints;\n      while (usablePoints--) {\n        // forEach pass add 1 the skills name to be used\n        thisRun.push([skillName, skillCost]);\n      }\n      // all points needed are accounted for break cost loop if not continue to next skill\n      if (!maxPoints) break costLoop;\n      if (!timesUsed) continue costLoop;\n    }\n    for (const [skillName, skillPointsAvailable] of Object.entries(remainingSkillsSorted[skillCost])) {\n      // if not skill or if only 1 point or if this is the last skillSlot available and wont be enough points continue\n      if (skillPointsAvailable < 2) continue;\n      // this method adds a new innateSkill\n      if (--skillsLimit < 0) break costLoop;\n      let usablePoints = Math.min(timesUsed, skillPointsAvailable);\n      thisRun[0] += +skillCost * usablePoints;\n      maxPoints -= usablePoints;\n      timesUsed -= usablePoints;\n      while (usablePoints--) {\n        // forEach pass add 1 occurrence of the skills name to be used\n        thisRun.push([skillName, skillCost]);\n      }\n      // all points needed are accounted for break cost loop if not continue to next skill\n      if (!maxPoints) break costLoop;\n      if (!timesUsed) continue costLoop;\n    }\n  }\n  return thisRun;\n}\n\nconst getDecos = ([...slotsRemaining], skillsRemaining, skillInfo, shouldUselvl1, skillsFoundOnArmors) => {\n  const decorations = {};\n  decorations.remainingSkills = {};\n  // decorations.remainingSkills.arr = [];\n  decorations.decosUsed = [];\n  for (let i = 0; i < skillsRemaining.length && slotsRemaining[3] > 0; i++) {\n    // for (let j = 0; j < remainingSkills.length && remainingSlots[3] > 0; j++) {\n    // Let remainingSkills[j][0] = Object.keys(remainingSkills)[j];\n    const { lvl4 } = skillInfo[skillsRemaining[i][0]];\n    if (\n      lvl4 !== 0 &&\n      skillsRemaining[i][1] <= -lvl4 &&\n      (skillInfo[skillsRemaining[i][0]].lvl !== 1 || (shouldUselvl1 -= lvl4) >= 0)\n    ) {\n      const slotsUsed = ~~Math.min(slotsRemaining[3], -skillsRemaining[i][1] / lvl4);\n      slotsRemaining[3] -= slotsUsed;\n      skillsRemaining[i][1] += lvl4 * slotsUsed;\n      decorations.decosUsed.push([skillsRemaining[i][0], lvl4, \"Slot lvl4\", slotsUsed]);\n    }\n  }\n\n  let counter = -1;\n  for (const [skillName, pointsNeeded] of skillsRemaining) {\n    ++counter;\n    if (pointsNeeded >= 0) continue;\n\n    let sum = 0;\n    switch (skillInfo[skillName].lvl) {\n      case 1:\n        sum = Math.min(-pointsNeeded, slotsRemaining[0]);\n        break;\n      case 2:\n        sum = Math.min(-pointsNeeded, slotsRemaining[1] + slotsRemaining[2] + slotsRemaining[3]);\n        break;\n      case 3:\n        sum = Math.min(-pointsNeeded, slotsRemaining[2] + slotsRemaining[3]);\n        break;\n      case 4:\n        sum = Math.min(-pointsNeeded, slotsRemaining[3]);\n        break;\n      default:\n        sum = 0;\n    } // if points will be left over\n    // sum = skillsFoundOnArmors[skillName] ? Math.max(0, sum - 1) : sum;\n    if (sum + pointsNeeded < 0) {\n      const { qurious } = skillInfo[skillName];\n      const remainder = sum + pointsNeeded;\n      if (!decorations.remainingSkills[qurious]) {\n        decorations.remainingSkills[qurious] = { total: 0 };\n      }\n      // keeps track for point of no chance of Success\n      // if ((qurious >= 3 && (usedAugments += remainder) < 0) || (qurious < 3 && (usedAugments += remainder / 1.25) < 0)) {\n      // return false;\n      // }\n      decorations.remainingSkills[qurious][skillName] = 0;\n      // sets up object with remainingSkills for augment function\n      decorations.remainingSkills[qurious].total -= remainder;\n      decorations.remainingSkills[qurious][skillName] -= remainder;\n      // decorations.remainingSkills.arr.push(qurious);\n\n      if (!sum) {\n        continue;\n      }\n    }\n\n    // -2 adjusts for the one level to match array index and the ++ right after this\n    let slotLevel = skillInfo[skillName].lvl - 2;\n    // iterate through deco slots starting with the lowest usable lvl and place skills\n    while (slotLevel++ < 4) {\n      if (!slotsRemaining[slotLevel]) {\n        continue;\n      }\n      // gets amount of usable slots\n      const min = Math.min(sum, slotsRemaining[slotLevel], -skillsRemaining[counter][1]);\n      slotsRemaining[slotLevel] -= min;\n      skillsRemaining[counter][1] += min;\n      // keep log of slots used\n      decorations.decosUsed.push([skillName, 1, `Slot lvl${slotLevel + 1}`, min]);\n      // if no skill levels needed break\n      if (skillsRemaining[counter][1] === 0) {\n        break;\n      }\n    }\n  }\n\n  return [decorations, slotsRemaining];\n};\nconst sortSkills = remainingSkills => {\n  return Object.fromEntries(\n    Object.entries(remainingSkills).map(([cost, skillObj]) => [\n      cost,\n      Object.fromEntries(\n        Object.entries(skillObj)\n          .filter(skill => skill[0] !== \"total\")\n          .sort(([skillA, pointsA], [skillB, pointsB]) => pointsB - pointsA)\n      )\n    ])\n  );\n};\nfunction SkillRestrictedCombinations3(remainingSkills, innateSkills, costArr, budget) {\n  let bestSolution = [0];\n  const remainingSkillsSorted = sortSkills(remainingSkills);\n  let costUsed = {};\n\n  for (let i = 0; i < costArr.length; i++) {\n    costUsed = { [costArr[i]]: 1 };\n\n    for (let j = i + 1; j < costArr.length; j++) {\n      costUsed[costArr[j]] = (costUsed[costArr[j]] || 0) + 1;\n      const abSum = costArr[i] + costArr[j];\n\n      for (let k = j + 1; k < costArr.length; k++) {\n        if (abSum + costArr[k] > budget) break;\n        costUsed[costArr[k]] = (costUsed[costArr[k]] || 0) + 1;\n\n        const thisRun = addSkills(innateSkills, remainingSkillsSorted, [0], costUsed, 5 - innateSkills.size, 3);\n\n        if (thisRun[0] <= budget && thisRun[0] > bestSolution[0]) {\n          [...bestSolution] = thisRun;\n        }\n\n        // Reset the value of costUsed for costArr[k] after processing this combination\n        if (costUsed[costArr[k]] > 1) {\n          --costUsed[costArr[k]];\n        } else {\n          delete costUsed[costArr[k]];\n        }\n      }\n\n      // Reset the value of costUsed for costArr[j] after processing all combinations with costArr[j]\n      if (costUsed[costArr[j]] > 1) {\n        --costUsed[costArr[j]];\n      } else {\n        delete costUsed[costArr[j]];\n      }\n    }\n  }\n  return bestSolution;\n}\n\nfunction SkillRestrictedCombinations2(remainingSkills, innateSkills, costArr, budget) {\n  let bestSolution = [0];\n  // augments available\n  const remainingSkillsSorted = sortSkills(remainingSkills);\n  for (let i = 0; i < costArr.length; i++) {\n    const a = costArr[i];\n    for (let j = i + 1; j < costArr.length; j++) {\n      const b = costArr[j];\n\n      if (a + b > budget) {\n        break;\n      }\n      // reduces the skills used for each cost\n      const costsUsed = {\n        [a]: 1\n      };\n      costsUsed[b] = (costsUsed[b] || 0) + 1;\n      const thisRun = addSkills(innateSkills, remainingSkillsSorted, [0], costsUsed, 5 - innateSkills.size, 2);\n      // if this solution used more points and is under the budget then save this run\n      if (thisRun[0] <= budget && thisRun[0] > bestSolution[0]) {\n        [...bestSolution] = thisRun;\n      }\n    }\n  }\n  return bestSolution;\n}\nconst findBestSum3 = (costArr, budget) => {\n  let previous = [0, 0, 0, 0];\n  for (let i = 0; i < costArr.length; i++) {\n    const a = costArr[i];\n\n    for (let k = i + 1; k < costArr.length; k++) {\n      const b = a + costArr[k];\n\n      for (let j = k + 1; j < costArr.length; j++) {\n        const total = b + costArr[j];\n        if (total < budget) {\n          if (total > previous[3]) {\n            previous = [a, b - a, total - b, total];\n          }\n          continue;\n        }\n        if (total === budget) return [a, b - a, total - b, total];\n        return previous;\n      }\n    }\n  }\n  return previous;\n};\nconst findBestSum2 = (costArr, budget) => {\n  let previous = [0, 0, 0];\n  for (let i = 0; i < costArr.length; i++) {\n    const b = costArr[i];\n\n    for (let j = i + 1; j < costArr.length; j++) {\n      const total = b + costArr[j];\n      if (total < budget) {\n        if (total > previous[2]) {\n          previous = [b, total - b, total];\n        }\n        continue;\n      }\n      if (total === budget) return [b, total - b, total];\n      return previous;\n    }\n  }\n  return previous;\n};\n// const findBestSum3 = (costArr, budget) => {\n//   for (let i = 0, j = 1, k = 2, len = costArr.length; k < len; i++, j++, k++) {\n//     // sum < target continue to next pass\n//     if (costArr[i] + costArr[j] + costArr[k] < budget) {\n//       continue;\n//     }\n//     // if sum === budget\n//     if (costArr[i] + costArr[j] + costArr[k] === budget || i === 0) {\n//       return [costArr[i], costArr[j], costArr[k], costArr[i] + costArr[j] + costArr[k]];\n//     }\n//     // backtrack i, sum <= budget\n//     if (costArr[--i] + costArr[j] + costArr[k] <= budget) {\n//       return [costArr[i], costArr[j], costArr[k], costArr[i] + costArr[j] + costArr[k]];\n//     }\n//     // backtrack j, sum <= budget\n//     if (costArr[i] + costArr[--j] + costArr[k] <= budget) {\n//       return [costArr[i], costArr[j], costArr[k], costArr[i] + costArr[j] + costArr[k]];\n//     }\n//     // backtrack k giving the previous passes totals so it must be < budget\n//     return [costArr[i], costArr[j], costArr[k - 1], costArr[i] + costArr[j] + costArr[k - 1]];\n//   }\n//   // if loop completed without finding value > budget return highest 3 costs\n//   const len = costArr.length;\n//   return [costArr[len - 3], costArr[len - 2], costArr[len - 1], costArr[len - 3] + costArr[len - 2] + costArr[len - 1]];\n// };\n// const findBestSum2 = (costArr, budget) => {\n//   for (let i = 0, j = 1; j < costArr.length; i++, j++) {\n//     // sum > target continue to next pass\n//     if (costArr[i] + costArr[j] < budget) {\n//       continue;\n//     }\n//     // if === target\n//     if (costArr[i] + costArr[j] === budget || i === 0) {\n//       return [costArr[i], costArr[j], costArr[i] + costArr[j]];\n//     }\n//     // backtrack i <= target\n//     if (costArr[--i] + costArr[j] <= budget) {\n//       return [costArr[i], costArr[j], costArr[i] + costArr[j]];\n//     }\n//     // backtrack j giving the previous passes totals so it must be < target\n//     return costArr.slice(-2).concat(costArr.slice(-2).reduce((a, b) => a + b)[0]);\n//   }\n//   const len = costArr.length;\n//   return [costArr[len - 2], costArr[len - 1], costArr[len - 2] + costArr[len - 1]];\n// };\n\nconst findBestSum1 = (costArr, target) => {\n  const returnVal = +costArr.filter(cost => cost <= target).pop();\n  return [returnVal, returnVal];\n};\n// allocates extra points if cant fit total maximum augs.\nconst getPoints = (thisPiece, listOfUsedSkills) => {\n  // checks if piece has more then 3 points in unused skills(3 +points augments are already used)\n  let augPointer = 0;\n  if (thisPiece.fodderSkills.length > 0) {\n    ++augPointer;\n    ++thisPiece.skillsRemovedCount;\n  }\n  // if result === 5 then no more skills so use a -Def for extra points\n  const pointsAdjustment = (1 + augPointer) * 5;\n  const augCost = !augPointer ? pointsAdjustment : thisPiece.fodderSkills.pop();\n  const augType = !augPointer ? \"-Def\" : \"-Skill\";\n\n  thisPiece.augs.push({ [augType]: augCost });\n  listOfUsedSkills.push([augCost, augType, thisPiece.name, 1]);\n\n  thisPiece.quriousPoints += pointsAdjustment;\n  // all costs are / 3 to de-bloat the values.\n  thisPiece.unBloatedPoints = ~~(thisPiece.quriousPoints / 3);\n  return [thisPiece, listOfUsedSkills];\n};\nconst pushAugs = (augs, thisPiece, remainingSkills, listOfUsedSkills) => {\n  let decrementValue = 0;\n  for (const aug of augs) {\n    const [augmentedSkill, cost] = Array.isArray(aug) ? aug : [Object.keys(remainingSkills[aug])[1], aug];\n    thisPiece.augs.push({ \"+Skill\": augmentedSkill });\n    listOfUsedSkills.push([augmentedSkill, 1, thisPiece.name, 1]);\n    thisPiece.innateSkills.add(augmentedSkill);\n    if (--remainingSkills[cost].total === 0) {\n      delete remainingSkills[cost];\n    } else if (--remainingSkills[cost][augmentedSkill] === 0) {\n      delete remainingSkills[cost][augmentedSkill];\n    }\n    decrementValue--;\n  }\n  return decrementValue;\n};\n\nconst minimumCostForPossibleAugs = (possibleAugs, entries) => {\n  let sum = 0;\n  for (let pointer = 0; possibleAugs && pointer < entries.length; ++pointer) {\n    const thisLimit = Math.min(entries[pointer][1].total, possibleAugs);\n    sum += thisLimit * +entries[pointer][0];\n    possibleAugs -= thisLimit;\n  }\n  return sum;\n};\nconst getQuriousSkills = (decoReturn, theseArmors, skillInfo, fullListOfRequiredSkills) => {\n  const extraSkills = [0, 0, 0, 0, 0];\n  const newArmorSkills = {};\n  const newDecoSkills = [0, 0, 0, 0];\n  let { decosUsed: listOfUsedSkills, remainingSkills } = decoReturn;\n  // if (remainingSkills[20]) delete remainingSkills[\"20\"];\n  // extraPointsAugLimit += 5;\n  const [...decoList] = listOfUsedSkills;\n\n  let totalRemainingAugments = Object.values(remainingSkills).reduce((acc, cur) => acc + cur.total, 0);\n\n  const armorPieces = [];\n  let armorPiece;\n  let augList;\n  const usableAugs = [];\n  for (const thisArmor of theseArmors) {\n    armorPiece = { ...thisArmor };\n    armorPiece.augs = [...thisArmor.augs];\n    armorPiece.fodderSkills = [...thisArmor.fodderSkills];\n    armorPiece.skillsRemovedCount = Math.min(3, thisArmor.fodderCount);\n    armorPiece.innateSkills = new Set(Object.keys(thisArmor.skills));\n    armorPieces.push(armorPiece);\n\n    const entries = Object.entries(remainingSkills);\n    if (!totalRemainingAugments || !entries.length) {\n      continue;\n    }\n\n    let possibleAugs = Math.min(6 - armorPiece.augs.length, totalRemainingAugments);\n    let augmentAdjustment =\n      totalRemainingAugments < 6 - armorPiece.augs.length ? 6 - armorPiece.augs.length - totalRemainingAugments : 0;\n\n    // if remaining needed augs are less than the armor can fit\n    while (possibleAugs && minimumCostForPossibleAugs(possibleAugs, entries) > armorPiece.unBloatedPoints) {\n      ++augmentAdjustment;\n      --possibleAugs;\n    }\n    if (!possibleAugs) {\n      continue;\n    }\n    while (augmentAdjustment--) {\n      [armorPiece, listOfUsedSkills] = getPoints(armorPiece, listOfUsedSkills);\n    }\n\n    // creates an array of the maximum usable remaining skills costs    example:[3,4,4,4,5,5,5]\n    usableAugs.length = 0;\n    for (const key in remainingSkills) {\n      let keysToAdd = Math.min(remainingSkills[key].total, possibleAugs);\n      while (keysToAdd--) {\n        usableAugs.push(+key);\n      }\n    }\n\n    // finds best augment combination from the usableAugs arr and the budget\n    // tests if the skill limit could be exceeded\n    if (5 - armorPiece.innateSkills.size >= possibleAugs) {\n      if (possibleAugs === 3) {\n        augList = findBestSum3(usableAugs, armorPiece.unBloatedPoints);\n      } else if (possibleAugs === 2) {\n        augList = findBestSum2(usableAugs, armorPiece.unBloatedPoints);\n      } else if (possibleAugs === 1 && armorPiece.unBloatedPoints >= usableAugs[0]) {\n        augList = findBestSum1(usableAugs, armorPiece.unBloatedPoints);\n      } else {\n        continue;\n      }\n      if ((armorPiece.quriousPoints -= Number(augList.pop() * 3)) < 0 || armorPiece.quriousPoints === undefined) {\n        console.log(`${armorPiece.name} has ${armorPiece.quriousPoints} points}`, armorPiece);\n        debugger;\n      }\n    } else {\n      if (possibleAugs === 3) {\n        augList = SkillRestrictedCombinations3(\n          remainingSkills,\n          armorPiece.innateSkills,\n          usableAugs,\n          armorPiece.unBloatedPoints\n        );\n      } else if (possibleAugs === 2) {\n        augList = SkillRestrictedCombinations2(\n          remainingSkills,\n          armorPiece.innateSkills,\n          usableAugs,\n          armorPiece.unBloatedPoints\n        );\n      } else if (possibleAugs === 1) {\n        console.log(\"limit 1\");\n      }\n      if ((armorPiece.quriousPoints -= Number(augList.shift() * 3)) < 0 || armorPiece.quriousPoints === undefined) {\n        console.log(`${armorPiece.name} has ${armorPiece.quriousPoints} points}`, armorPiece);\n        debugger;\n      }\n    }\n\n    totalRemainingAugments += pushAugs(augList, armorPiece, remainingSkills, listOfUsedSkills);\n  }\n\n  const replaceAugment = (armorPiece, k) => {\n    armorPiece.augs.splice(k, 1);\n    const augList = findBestSum1(Object.keys(remainingSkills), ~~(armorPiece.quriousPoints / 3));\n    if (!augList[0]) return;\n    armorPiece.quriousPoints -= augList[1] * 3;\n    totalRemainingAugments += pushAugs([augList[0]], armorPiece, remainingSkills, listOfUsedSkills);\n  };\n\n  if (totalRemainingAugments > 0) {\n    for (const armorPiece of armorPieces) {\n      if (\n        armorPiece.innateSkills.size > 4 &&\n        Object.entries(remainingSkills).filter(x => Object.keys(x[1]).every(y => !armorPiece.innateSkills.has(y)))\n      ) {\n        continue;\n      }\n      if (!Object.keys(remainingSkills).length) break;\n\n      for (let k = armorPiece.augs.length - 1; k >= 0; k--) {\n        if (armorPiece.augs[k][\"-Def\"] && armorPiece.quriousPoints - 5 >= +Object.keys(remainingSkills)[0] * 3) {\n          armorPiece.quriousPoints -= 5;\n          replaceAugment(armorPiece, k);\n          break; // exit the loop when the first occurrence is found\n        } else if (\n          armorPiece.augs[k][\"-Skill\"] &&\n          armorPiece.quriousPoints - 10 >= +Object.keys(remainingSkills)[0] * 3\n        ) {\n          armorPiece.quriousPoints -= 10;\n          replaceAugment(armorPiece, k);\n          break; // exit the loop when the first occurrence is found\n        }\n      }\n    }\n  }\n  if (Object.keys(remainingSkills).length) {\n    return {\n      quriousAugs: 0,\n      finalSkillCheck: 0,\n      returnArmors: 0,\n      arr: false\n    };\n  }\n\n  // console.log(\"here\");\n\n  for (const armorPiece of armorPieces) {\n    // for (let k = 0; k < 5; k++) {\n    // let armorPiece = returnArmors[k];\n    if (armorPiece.quriousPoints < 5 || !armorPiece.fodderCount) continue;\n    const min = Math.min(armorPiece.fodderCount, ~~(armorPiece.quriousPoints / 5));\n    for (const [skillName, maxPoints] of Object.entries(armorPiece.skills)) {\n      newArmorSkills[skillName] =\n        (newArmorSkills[skillName] || 0) + Math.min(skillInfo[skillName]?.max || 5, maxPoints, min);\n    }\n    // if (!newSkills[skillName]) {\n    // ?\n    // : min;\n    // } else {\n    // newSkills[skillName] += fullListOfRequiredSkills[skillName]\n    // ? Math.min(skillInfo[skillName].max - fullListOfRequiredSkills[skillName], min)\n    // : min;\n    // }\n    // });\n\n    // Continue to the next iteration if armorPiece.points is less than 8.\n    if (armorPiece.innateSkills.size > 4 || armorPiece.quriousPoints < 8) continue;\n    // Calculate the number of empty slots for augmentations.\n    let augCount = armorPiece.augs.length;\n    let defCount = 3 - armorPiece.skillsRemovedCount;\n    // Increase the defCount by 1 if the third or fourth augment slot is occupied by a defense augment.\n    let extraPoints = armorPiece.quriousPoints;\n    // Iterate while the number of augmentations is less than or equal to 3.\n    while (--augCount >= 0) {\n      // Deduct 5 points if there is still space for a defense augment, or deduct 10 otherwise.\n      if ((extraPoints -= --defCount >= 0 ? 5 : 10) < augCount * 3) {\n        // Break the loop if there are not enough points left for the current number of augmentations.\n        break;\n      }\n      // Calculate the number of times the loop should iterate.\n      let pointer = ~~(extraPoints / augCount / 3);\n      // Decrement the pointer for each iteration of the loop.\n      while (pointer--) {\n        // Increment the value at the corresponding index of the `extraSkills` array.\n        ++extraSkills[pointer];\n      }\n      // Continue to the next iteration.\n      continue;\n    }\n    // get deco Slots\n    for (let i = 0; i < 5; ++i) {\n      if (extraSkills[i] === 0) continue;\n      let remainingExtraSkills = extraSkills[i];\n      // Iterate through list of decos used\n      for (const [skillName, pointPer, slotLevel, timesUsed] of decoList) {\n        // If this skill's qurious cost is <= this qurious cost, then a deco slot can be freed up.\n        if (skillInfo[skillName].quriousPoints * pointPer > (i + 1) * 3) continue;\n        // Keeps track of the highest deco slots that could be freed up.\n        let thisCostBestResult = skillInfo[skillName].lvl - 1;\n        let timesUsedThisDeco = Math.min(timesUsed, remainingExtraSkills);\n\n        // Update newDecoSkills for this skill\n        newDecoSkills[thisCostBestResult] = (newDecoSkills[thisCostBestResult] || 0) + timesUsedThisDeco;\n\n        // Update remainingExtraSkills\n        remainingExtraSkills -= timesUsedThisDeco;\n\n        // If no more extraSkills to distribute, break the loop\n        if (remainingExtraSkills === 0) break;\n      }\n    }\n  }\n\n  return {\n    quriousAugs: listOfUsedSkills,\n    armorPieces,\n    theseExtraPoints: extraSkills,\n    newArmorSkills,\n    newDecoSkills,\n    arr: !totalRemainingAugments\n  };\n};\n\nconst combineDecos = (decoArrs, charmDecos) => {\n  const [...returnDecos] = charmDecos;\n  decoArrs.forEach(decoArr => {\n    returnDecos[0] += decoArr[0];\n    returnDecos[1] += decoArr[1];\n    returnDecos[2] += decoArr[2];\n    returnDecos[3] += decoArr[3];\n  });\n  return returnDecos;\n};\nconst max = (a, b) => (a >= b ? a : b);\nconst getMostSkills = (newSets, returningVal) => {\n  for (const newSet of newSets) {\n    for (let i = 0; i < 4; i++) {\n      returningVal.remainingSlots[i] = max(returningVal.remainingSlots[i] || 0, newSet.remainingSlots[i]);\n    }\n    //\n    for (let i = 0; i < 5; i++) {\n      returningVal.quriousSkills[i] = max(returningVal.quriousSkills[i] || 0, newSet.quriousSkills[i]);\n    }\n    //\n    for (const [skill, lvl] of Object.entries(newSet.armorSkills)) {\n      returningVal.armorSkills[skill] = max(returningVal.armorSkills[skill] || 0, lvl);\n    }\n  }\n};\nself.addEventListener(\"message\", e => {\n  const final = {\n    sets: [],\n    count: { sets: 0, combos: 0 },\n    stats: { quriousSkills: [0, 0, 0, 0, 0], armorSkills: {}, remainingSlots: [0, 0, 0, 0] }\n  };\n  e.data.requiredSkills = Object.entries(e.data.skills);\n\n  const processBatch = permutations => {\n    for (const value of Object.values(permutations)) {\n      e.data.theseArmors = [\n        e.data.armors.helm[value[0]],\n        e.data.armors.chest[value[1]],\n        e.data.armors.arm[value[2]],\n        e.data.armors.waist[value[3]],\n        e.data.armors.leg[value[4]]\n      ];\n      const thisRun = testThisBatch(e.data);\n      if (thisRun) {\n        getMostSkills(thisRun, final.stats);\n        final.count.combos += thisRun.length;\n        ++final.count.sets;\n        if (final.sets.length < 50) final.sets.push(thisRun);\n      }\n    }\n\n    postMessage({ type: \"rerun\", final });\n  };\n\n  processBatch(e.data.permutations);\n  self.terminate;\n});\n\nconst testThisBatch = data => {\n  const { thisWeapon, theseCharms: charmList, requiredSkills, skillInfo, theseArmors, skills } = data;\n  theseArmors.sort((a, b) => {\n    const augsDiff = 6 - a.augs.length - ((6 - a.augs.length) / a.quriousPoints <= 10 ? 1 : 0);\n    const skillsDiff = 5 - Object.keys(a.skills).length;\n\n    const bAugsDiff = 6 - b.augs.length - ((6 - b.augs.length) / b.quriousPoints <= 10 ? 1 : 0);\n    const bSkillsDiff = 5 - Object.keys(b.skills).length;\n\n    return bSkillsDiff - bAugsDiff - (skillsDiff - augsDiff);\n  });\n\n  const theseArmorSkills = {};\n  for (const armor of theseArmors) {\n    for (const [skillName, pointsGained] of Object.entries(armor.skills)) {\n      if (!skills[skillName]) continue;\n      theseArmorSkills[skillName] = (theseArmorSkills[skillName] || 0) + pointsGained;\n    }\n  }\n  const decoArr = combineDecos(\n    [\n      thisWeapon,\n      theseArmors[0].decos,\n      theseArmors[1].decos,\n      theseArmors[2].decos,\n      theseArmors[3].decos,\n      theseArmors[4].decos\n    ],\n    data.charmSlots\n  );\n  // for (let i = 0; i < 5; i++) {\n  // if (theseArmors[i].unBloatedPoints / (6 - theseArmors[i].augs[0].length) >= 3) {\n  // theseArmors[i].sortBy = theseArmors[i].unBloatedPoints / (6 - theseArmors[i].augs[0].length);\n  // } else if ((theseArmors[i].unBloatedPoints + 2) / (6 - theseArmors[i].augs[0].length - 1) >= 3) {\n  // theseArmors[i].sortBy =\n  // (6 - theseArmors[i].augs[0].length - Object.keys(theseArmors.skills).length) / theseArmors.unBloatedPoints;\n  // }\n  // }\n  theseArmors.sort((a, b) => {\n    const augsDiff = 6 - a.augs.length - ((6 - a.augs.length) / a.quriousPoints <= 10 ? 1 : 0);\n    const skillsDiff = 5 - Object.keys(a.skills).length;\n\n    const bAugsDiff = 6 - b.augs.length - ((6 - b.augs.length) / b.quriousPoints <= 10 ? 1 : 0);\n    const bSkillsDiff = 5 - Object.keys(b.skills).length;\n\n    return skillsDiff - augsDiff - (bSkillsDiff - bAugsDiff);\n  });\n\n  // let totals = 30;\n  // theseArmors.forEach((thisArmor) => (totals -= thisArmor.augs.length));\n  // for (let i = 0, keys = Object.keys(thisCharm); i < keys.length; i++) {\n  // let skillName = keys[i];\n  // let skillLevel = thisCharm[skillName];\n  // if (skillsStillNeeded[skillName] + skillLevel > skillInfo[skillName].max) {\n  // return;\n  // }\n  // }\n  let returnVal = [];\n  charmList.forEach(thisCharm => {\n    if (\n      Object.entries(thisCharm).every(\n        ([skillName, points]) =>\n          !theseArmorSkills[skillName] || theseArmorSkills[skillName] + points <= skillInfo[skillName].max\n      )\n    ) {\n      return;\n    }\n\n    const remainingSkills = [];\n    // let lvl4count = -decoArr[3];\n    let lvl1count = -decoArr[0];\n    for (let [skillName, pointsNeeded] of requiredSkills) {\n      if (theseArmorSkills[skillName]) {\n        pointsNeeded += theseArmorSkills[skillName];\n      }\n      if (thisCharm[skillName]) {\n        pointsNeeded += thisCharm[skillName];\n      }\n      const { lvl, max } = skillInfo[skillName];\n      if (pointsNeeded > max) return;\n      // if skill is not level 1 and has a level 4 version || if it is lvl 1 and set doesn't have enough level 1 slots\n      if (lvl === 1) lvl1count -= pointsNeeded;\n      //  only adds points if it needs the amount of points the lvl 4 gives\n      // lvl4count -= ~~(pointsNeeded / lvl4);\n      // }\n      // if (lvl === 1) lvl1count -= pointsNeeded;\n      if (pointsNeeded < 0) {\n        remainingSkills.push([skillName, pointsNeeded]);\n      }\n    }\n\n    const [returnDecos, remainingSlots] = getDecos(\n      decoArr.slice(0),\n      remainingSkills,\n      skillInfo,\n      lvl1count,\n      theseArmorSkills\n    );\n    // if (!returnDecos.check) return false;\n\n    const {\n      quriousAugs,\n      armorPieces,\n      theseExtraPoints: quriousSkills,\n      newArmorSkills,\n      newDecoSkills,\n      arr\n    } = getQuriousSkills(returnDecos, theseArmors, skillInfo, skills);\n\n    if (!arr) return false;\n    if (armorPieces.some(armor => armor.name == undefined)) {\n      debugger;\n      console.log(armorPieces);\n    }\n    returnVal.push({\n      usedSkills: [].concat(\n        quriousAugs,\n        Object.entries(theseArmorSkills),\n        Object.entries(thisCharm)\n        // Object.entries(thisCharm)[1])\n      ),\n      armors: [\n        [armorPieces[0].name, armorPieces[0]],\n        [armorPieces[1].name, armorPieces[1]],\n        [armorPieces[2].name, armorPieces[2]],\n        [armorPieces[3].name, armorPieces[3]],\n        [armorPieces[4]?.name, armorPieces[4]]\n      ],\n      remainingSlots: combineDecos(newDecoSkills, remainingSlots),\n      quriousSkills,\n      armorSkills: newArmorSkills,\n      thisCharm,\n      decoArr\n    });\n  });\n  // returnVal = returnVal.filter((set) => {\n  // let usedSkillList = {};\n  // set.usedSkills.forEach(([skillName, pointsPerUse, augmentType, timesUsed]) => {\n  // let points = pointsPerUse * timesUsed;\n\n  // usedSkillList[skillName] = (usedSkillList[skillName] || 0) + points;\n  // });\n  // if (data.requiredSkills.every(([skillName, pointsNeeded]) => (usedSkillList[skillName] += pointsNeeded >= 0))) {\n  // return true;\n  // }\n  // console.log({ set, ugh: usedSkillList, skills });\n  // debugger;\n  // });\n\n  if (!returnVal[0]) {\n    return;\n  }\n  const desiredOrder = [\"helm\", \"chest\", \"arm\", \"waist\", \"leg\"];\n  [...returnVal] = returnVal.map(set => {\n    set.armors.sort((a, b) => desiredOrder.indexOf(a[1]?.type) - desiredOrder.indexOf(b[1]?.type));\n    return set;\n  });\n  return returnVal;\n};\n"],"names":["addSkills","innateSkills","remainingSkillsSorted","thisRun","costsUsed","skillsLimit","maxPoints","costLoop","skillCost","timesUsed","Object","entries","skillName","values","usablePoints","Math","min","push","skillPointsAvailable","sortSkills","remainingSkills","fromEntries","map","cost","skillObj","filter","skill","sort","skillA","pointsA","skillB","pointsB","SkillRestrictedCombinations3","costArr","budget","bestSolution","costUsed","i","length","j","abSum","k","size","SkillRestrictedCombinations2","a","b","findBestSum3","previous","total","findBestSum2","findBestSum1","target","returnVal","pop","getPoints","thisPiece","listOfUsedSkills","augPointer","fodderSkills","skillsRemovedCount","pointsAdjustment","augCost","augType","augs","name","quriousPoints","unBloatedPoints","pushAugs","decrementValue","aug","augmentedSkill","Array","isArray","keys","add","minimumCostForPossibleAugs","possibleAugs","sum","pointer","thisLimit","combineDecos","decoArrs","charmDecos","returnDecos","forEach","decoArr","max","getMostSkills","newSets","returningVal","newSet","remainingSlots","quriousSkills","lvl","armorSkills","self","addEventListener","e","final","sets","count","combos","stats","data","requiredSkills","skills","permutations","value","theseArmors","armors","helm","chest","arm","waist","leg","testThisBatch","postMessage","type","processBatch","terminate","thisWeapon","theseCharms","charmList","skillInfo","augsDiff","skillsDiff","bAugsDiff","theseArmorSkills","armor","pointsGained","decos","charmSlots","thisCharm","every","points","lvl1count","pointsNeeded","slotsRemaining","skillsRemaining","shouldUselvl1","skillsFoundOnArmors","decorations","lvl4","slotsUsed","decosUsed","counter","qurious","remainder","slotLevel","getDecos","slice","quriousAugs","armorPieces","theseExtraPoints","newArmorSkills","newDecoSkills","arr","decoReturn","fullListOfRequiredSkills","extraSkills","decoList","totalRemainingAugments","reduce","acc","cur","armorPiece","augList","usableAugs","thisArmor","fodderCount","Set","augmentAdjustment","key","keysToAdd","Number","undefined","console","log","shift","replaceAugment","splice","x","y","has","finalSkillCheck","returnArmors","augCount","defCount","extraPoints","remainingExtraSkills","pointPer","thisCostBestResult","timesUsedThisDeco","getQuriousSkills","some","usedSkills","concat","desiredOrder","set","indexOf"],"sourceRoot":""}
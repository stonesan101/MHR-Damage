const getDecos=([...t],s,e,o,n)=>{const i={remainingSkills:{},decosUsed:[]};for(let n=0;n<s.length&&t[3]>0;n++){const{lvl4:l}=e[s[n][0]];if(0!==l&&s[n][1]<=-l&&(1!==e[s[n][0]].lvl||(o-=l)>=0)){const e=~~Math.min(t[3],-s[n][1]/l);t[3]-=e,s[n][1]+=l*e,i.decosUsed.push([s[n][0],l,"Slot lvl4",e])}}let l=-1;for(const[o,n]of s){if(++l,n>=0)continue;let r=0;switch(e[o].lvl){case 1:r=Math.min(-n,t[0]);break;case 2:r=Math.min(-n,t[1]+t[2]+t[3]);break;case 3:r=Math.min(-n,t[2]+t[3]);break;case 4:r=Math.min(-n,t[3]);break;default:r=0}if(r+n<0){const{qurious:t}=e[o],s=r+n;if(i.remainingSkills[t]||(i.remainingSkills[t]={total:0}),i.remainingSkills[t][o]=0,i.remainingSkills[t].total-=s,i.remainingSkills[t][o]-=s,!r)continue}let u=e[o].lvl-2;for(;u++<4;){if(!t[u])continue;const e=Math.min(r,t[u],-s[l][1]);if(t[u]-=e,s[l][1]+=e,i.decosUsed.push([o,1,`Slot lvl${u+1}`,e]),0===s[l][1])break}}return[i,t]};function addSkills(t,s,e,o,n,i){t:for(let[l,r]of Object.entries(o)){for(const o of t.values()){if(!s[l][o])continue;let t=Math.min(r,s[l][o]);for(e[0]+=+l*t,i-=t,r-=t;t--;)e.push([o,l]);if(!i)break t;if(!r)continue t}for(const[t,o]of Object.entries(s[l])){if(o<2)continue;if(--n<0)break t;let s=Math.min(r,o);for(e[0]+=+l*s,i-=s,r-=s;s--;)e.push([t,l]);if(!i)break t;if(!r)continue t}}return e}function SkillRestrictedCombinations3(t,s,e,o){let n=[0];const i=Object.fromEntries(Object.entries(t).map((([t,s])=>[t,Object.fromEntries(Object.entries(s).filter((([t,s])=>"total"!==t)).sort((([t,s],[e,o])=>o-s)))])));for(let t=0;t<e.length;t++){const l=e[t];for(let r=t+1;r<e.length;r++){const t=e[r];for(let u=r+1;u<e.length;u++){const r=e[u];if(l+t+r>o)break;const a={[l]:1};a[t]=(a[t]||0)+1,a[r]=(a[r]||0)+1;const c=addSkills(s,i,[0],a,5-s.size,3);c[0]<=o&&c[0]>n[0]&&([...n]=c)}}}return n}function SkillRestrictedCombinations2(t,s,e,o){let n=[0];const i=Object.fromEntries(Object.entries(t).map((([t,s])=>[t,Object.fromEntries(Object.entries(s).filter((([t,s])=>"total"!==t)).sort((([t,s],[e,o])=>o-s)))])));for(let t=0;t<e.length;t++){const l=e[t];for(let r=t+1;r<e.length;r++){const t=e[r];if(l+t>o)break;const u={[l]:1};u[t]=(u[t]||0)+1;const a=addSkills(s,i,[0],u,5-s.size,2);a[0]<=o&&a[0]>n[0]&&([...n]=a)}}return n}const findBestSum3=(t,s)=>{for(let e=0,o=1,n=2,i=t.length;n<i;e++,o++,n++)if(!(t[e]+t[o]+t[n]<s))return t[e]+t[o]+t[n]===s||0===e||t[--e]+t[o]+t[n]<=s||t[e]+t[--o]+t[n]<=s?[t[e],t[o],t[n],t[e]+t[o]+t[n]]:[t[e],t[o],t[n-1],t[e]+t[o]+t[n-1]];const e=t.length;return[t[e-3],t[e-2],t[e-1],t[e-3]+t[e-2]+t[e-1]]},findBestSum2=(t,s)=>{for(let e=0,o=1;o<t.length;e++,o++)if(!(t[e]+t[o]<s))return t[e]+t[o]===s||0===e||t[--e]+t[o]<=s?[t[e],t[o],t[e]+t[o]]:t.slice(-2).concat(t.slice(-2).reduce(((t,s)=>t+s))[0]);const e=t.length;return[t[e-2],t[e-1],t[e-2]+t[e-1]]},findBestSum1=(t,s)=>{const e=t.filter((t=>t<=s)).pop();return[e,e]},getPoints=(t,s)=>{let e=0;t.fodderSkills.length>0&&(++e,++t.skillsRemovedCount);const o=5*(1+e);return t.augs.push({[e?"-Skill":"-Def"]:[e?t.fodderSkills.pop():o]}),s.push([e?t.fodderSkills.pop():o,e?"-Skill":"-Def",t.name,1]),t.quriousPoints+=o,t.unBloatedPoints=~~(t.quriousPoints/3),[t,s]},pushAugs=(t,s,e,o,n)=>{for(const i of t){const[t,l]=Array.isArray(i)?i:[Object.keys(o[i])[1],i];s.augs.push({"+Skill":t}),n.push([t,1,s.name,1]),s.innateSkills.add(t),0==--o[l].total?delete o[l]:0==--o[l][t]&&delete o[l][t],--e}return e},minimumCostForPossibleAugs=(t,s)=>{let e=0;for(let o=0;t&&o<s.length;++o){const n=Math.min(s[o][1].total,t);e+=n*+s[o][0],t-=n}return e},getQuriousSkills=(t,s,e,o)=>{let{decosUsed:n,remainingSkills:i}=t,l=Object.values(i).reduce(((t,s)=>t+s.total),0);if(l>15)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};const r=[];for(let t=0;t<s.length;t++){let e={...s[t]};e.augs=[...s[t].augs],e.fodderSkills=[...s[t].fodderSkills],e.skillsRemovedCount=Math.min(3,s[t].fodderCount),e.innateSkills=new Set(Object.keys(s[t].skills)),r.push(e);const o=Object.entries(i);if(!l||!o.length)continue;let u=Math.min(6-e.augs.length,l),a=l<6-e.augs.length?6-e.augs.length-l:0;for(;u&&minimumCostForPossibleAugs(u,o)>e.unBloatedPoints;)++a,--u;if(!u)continue;for(;a--;)[e,n]=getPoints(e,n);const c=[];for(const t in i){let s=Math.min(i[t].total,u);for(;s--;)c.push(+t)}let f=[];if(5-e.innateSkills.size>=u){if(3===u)f=findBestSum3(c,e.unBloatedPoints);else if(2===u)f=findBestSum2(c,e.unBloatedPoints);else{if(!(1===u&&e.unBloatedPoints>=c[0]))continue;f=findBestSum1(c,e.unBloatedPoints)}((e.quriousPoints-=Number(3*f.pop()))<0||void 0===e.quriousPoints)&&console.log(`${e.name} has ${e.quriousPoints} points}`,e)}else 3===u?f=SkillRestrictedCombinations3(i,e.innateSkills,c,e.unBloatedPoints):2===u?f=SkillRestrictedCombinations2(i,e.innateSkills,c,e.unBloatedPoints):1===u&&console.log("limit 1"),((e.quriousPoints-=Number(3*f.shift()))<0||void 0===e.quriousPoints)&&console.log(`${e.name} has ${e.quriousPoints} points}`,e);l=pushAugs(f,e,l,i,n)}const u=(t,s)=>{t.augs.splice(s,1);const e=findBestSum1(Object.keys(i).filter((s=>+s<=~~(t.quriousPoints/3))));e[0]&&(t.quriousPoints-=3*e[1],l=pushAugs([e[0]],t,l,i,n))};if(l>0)for(const t of r){if(t.innateSkills.size>4&&Object.entries(i).filter((s=>Object.keys(s[1]).every((s=>!t.innateSkills.has(s))))))continue;if(!Object.keys(i).length)break;let s=t.augs.length-1;for(;--s;)t.augs.some((t=>t["-Def"]))&&t.quriousPoints-5>=3*+Object.keys(i)[0]?(t.quriousPoints-=5,u(t,s)):t.augs.some((t=>t["-Skill"]))&&t.quriousPoints-10>=3*+Object.keys(i)[0]&&(t.quriousPoints-=10,u(t,s))}if(Object.keys(i).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};const a=[0,0,0,0,0],c={};for(const t of r){if(t.quriousPoints<5||!t.fodderCount)continue;const s=Math.min(t.fodderCount,~~(t.quriousPoints/5));for(const[o,n]of Object.entries(t.skills))c[o]=Math.min(e[o]?.max||10,n,s);if(t.innateSkills.size>4||t.quriousPoints<8)continue;let o=t.augs.length,n=3-t.skillsRemovedCount,i=t.quriousPoints+0;for(;--o>=0&&!((i-=--n>=0?5:10)<3*o);){let t=~~(i/o/3);for(;t--;)++a[t]}}return{quriousAugs:n,armorPieces:r,theseExtraPoints:a,newSkills:c,arr:!l}},combineDecos=(t,s)=>{const[...e]=s;return t.forEach((t=>{e[0]+=t[0],e[1]+=t[1],e[2]+=t[2],e[3]+=t[3]})),e},max=(t,s)=>t>=s?t:s,getMostSkills=(t,s)=>{for(const e of t){for(let t=0;t<4;t++)s.remainingSlots[t]=max(s.remainingSlots[t],e.remainingSlots[t]);for(let t=0;t<5;t++)s.quriousSkills[t]=max(s.quriousSkills[t],e.quriousSkills[t]);for(const[t,o]of Object.entries(e.armorSkills))s.armorSkills[t]=max(s.armorSkills[t],o)}};self.addEventListener("message",(t=>{const s={count:[0,0],stats:{quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]},sets:[]};let e=1;t.data.requiredSkills=Object.entries(t.data.skills);for(const o of Object.values(t.data.permutations)){t.data.theseArmors=[t.data.armors.helm[o[0]],t.data.armors.chest[o[1]],t.data.armors.arm[o[2]],t.data.armors.waist[o[3]],t.data.armors.leg[o[4]]];const n=testThisBatch(t.data);n&&(getMostSkills(n,s.stats),s.count[1]+=n.length,++s.count[0],e&&s.sets.push(n)),e&&25===s.sets.length&&(--e,postMessage([s.sets,!1,s.count]),s.sets.length=0,s.count=[0,0])}postMessage([s.sets,s.stats,s.count])}));const testThisBatch=t=>{const{thisWeapon:s,theseCharms:e,requiredSkills:o,skillInfo:n,theseArmors:i,skills:l}=t;i.sort(((t,s)=>{const e=6-t.augs.length-((6-t.augs.length)/t.quriousPoints<=10?1:0),o=5-Object.keys(t.skills).length,n=6-s.augs.length-((6-s.augs.length)/s.quriousPoints<=10?1:0);return 5-Object.keys(s.skills).length-n-(o-e)}));const r={};for(const t of i)for(const[s,e]of Object.entries(t.skills))l[s]&&(r[s]=(r[s]||0)+e);const u=combineDecos([s,i[0].decos,i[1].decos,i[2].decos,i[3].decos,i[4].decos],t.charmSlots);i.sort(((t,s)=>{const e=6-t.augs.length-((6-t.augs.length)/t.quriousPoints<=10?1:0),o=5-Object.keys(t.skills).length,n=6-s.augs.length-((6-s.augs.length)/s.quriousPoints<=10?1:0);return o-e-(5-Object.keys(s.skills).length-n)}));let a=[];if(e.forEach((t=>{if(Object.entries(t).every((([t,s])=>!r[t]||r[t]+s<=n[t].max)))return;const s=[];let e=-u[0];for(let[i,l]of o){r[i]&&(l+=r[i]),t[i]&&(l+=t[i]);const{lvl:o,max:u}=n[i];if(l>u)return;1===o&&(e-=l),l<0&&s.push([i,l])}const[l,c]=getDecos(u.slice(0),s,n,e),{quriousAugs:f,armorPieces:m,theseExtraPoints:g,newSkills:h,arr:k}=getQuriousSkills(l,i,n);if(!k)return!1;m.some((t=>null==t.name))&&console.log(m),a.push({usedSkills:[].concat(f,Object.entries(r),Object.entries(t)),armors:[[m[0].name,m[0]],[m[1].name,m[1]],[m[2].name,m[2]],[m[3].name,m[3]],[m[4]?.name,m[4]]],remainingSlots:c,quriousSkills:g,armorSkills:h,thisCharm:t,decoArr:u})})),a[0]){const t=["helm","chest","arm","waist","leg"];return[...a]=a.map((s=>(s.armors.sort(((s,e)=>t.indexOf(s[1]?.type)-t.indexOf(e[1]?.type))),s))),a}};
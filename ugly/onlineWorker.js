const getDecos=([...a],d,c,g,h)=>{const k={remainingSkills:{},decosUsed:[]};(()=>{for(let e=0;e<d.length&&a[3];e++){const l=c[d[e][0]].lvl4;if(0!==l&&d[e][1]<=-1*l&&(1!==c[d[e][0]].lvl||0<=(h-=l))){const t=~~Math.min(a[3],-1*d[e][1]/l);a[3]-=t;d[e][1]+=l*t;k.decosUsed.push([d[e][0],l,"Slot lvl4",t])}}})();k.check=(()=>{for(const [t,y]of d){if(!y||20===c[t].querious)continue;let v;switch(c[t].lvl){case 1:v=Math.min(-1*y,a[0]);break;case 2:v=Math.min(-1*y,a[1]+a[2]+a[3]);break;case 3:v=Math.min(-1*
y,a[2]+a[3]);break;default:v=Math.min(-1*y,a[3])}if(0>v+y){var e=c[t].qurious,l=v+y;k.remainingSkills[e]||(k.remainingSkills[e]={total:0});if(3<=e&&0>(g+=l)||3>e&&0>(g+=l/1.25))return!1;for(k.remainingSkills[e][t]=0;l++;)++k.remainingSkills[e].total,++k.remainingSkills[e][t];if(!v)continue}for(e=c[t].lvl-2;4>e++&&(!a[e]||(l=Math.min(v,a[e]),a[e]-=l,k.decosUsed.push([t,1,`Slot lvl${e+1}`,l]),0!==y+l)););}return g})();return[k,a]};
function generateAugmentCombinations(a,d,c,g){let h=[];a:for(let k=0;k<c.length;k++){const e=c[k];for(let l=k+1;l<c.length;l++){const t=c[l];for(let y=l+1;y<c.length;y++){const v=c[y];let u=3-(5-d.size);if(e+t+v>g)break a;let m={a:1};m[t]?++m[t]:m[t]=1;m[v]?++m[v]:m[v]=1;b:for(let p=0,w=Object.entries(m);p<w.length;++p)c:for(const [D,b]of Object.entries(a[w[p][0]]))if("total"!==D)if(d.has(D)){if(0>=(u+=b))break b;if(0>=(w[p][1]+=b))break c}else if(1<b){if(0>=(u+=b))break b;if(0>=(w[p][1]+=b-1))break c}if(!(0<
u)&&(e+t+v<g&&(h=[e,t,v]),e+t+v>g))break a}}}return[h,h.reduce((k,e)=>k+e)]}
const findBestSum3=(a,d)=>{for(let c=0,g=1,h=2,k=a.length;h<k;c++,g++,h++)if(!(a[c]+a[g]+a[h]<d))return a[c]+a[g]+a[h]===d||0===c||a[--c]+a[g]+a[h]<=d||a[c]+a[--g]+a[h]<=d?[a[c],a[g],a[h],a[c]+a[g]+a[h]]:[a[c],a[g],a[h-1],a[c]+a[g]+a[h-1]];return[a[a.length-3],a[a.length-2],a[a.length-1],a[a.length-3]+a[a.length-2]+a[a.length-1]]},findBestSum2=(a,d)=>{for(let c=0,g=1;g<a.length;c++,g++)if(!(a[c]+a[g]<d))return a[c]+a[g]===d||0===c||a[--c]+a[g]<=d?[a[c],a[g],a[c]+a[g]]:[a[c],a[g-1],a[c]+a[g-1]];return[a[a.length-
2],a[a.length-1],a[a.length-2]+a[a.length-1]]},findBestSum1=(a,d)=>{a=a.filter(c=>c<=d).pop();return[a,a]},getQuriousSkills=(a,d,c,g)=>{let {check:h,decosUsed:k,remainingSkills:e}=a;h+=5;var l=0;a=[];let t=0;for(var y of Object.values(e))t+=y.total?y.total:0;y=b=>{let r=0;0<b.fodderSkills.length&&(++r,++b.skillsRemovedCount);const n=5*(1+r);b.augs.push({[r?"-Skill":"-Def"]:[r?b.fodderSkills.pop():n]});k.push([r?b.fodderSkills.pop():n,r?"-Skill":"-Def",b.name,1]);b.quriousPoints+=n;b.unbloatedPoints=
~~(b.quriousPoints/3)};const v=(b,r)=>{for(const n of b){if(4<r.innateSkills.size&&!Object.keys(e[n]).some(G=>r.innateSkills.has(G)))break;b=e[n];const C=Object.keys(b)[1];r.augs.push({"+Skill":C});k.push([C,1,r.name,1]);r.innateSkills.add(C);0===--b.total?delete e[n]:0===--b[C]&&delete b[C];--t}};for(var u=0;u<d.length;u++){let b={};b={...d[u]};b.augs=[...d[u].augs];b.fodderSkills=[...d[u].fodderSkills];b.skillsRemovedCount=Math.min(3,d[u].fodderCount);b.innateSkills=new Set(Object.keys(d[u].skills));
if(0>=t){a.push(b);continue}l=6-b.augs.length;if(t<l)for(;l>t;)y(b),--l;if(1>l){a.push(b);continue}var m=l,p=0;let r=0,n=0,C=Object.keys(e);for(;m--;)n+=+C[r],m&&++p>=e[C[r]].total&&(p=0,++r);if(b.unbloatedPoints<n){if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--l;y(b);if(b.unbloatedPoints<(n-=C[r])){if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--l;y(b);p||--r;if(b.unbloatedPoints<n-C[r]){if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,
arr:!1};--l;a.push(b);continue}}}m=[];for(var w in e)for(p=Math.min(e[w].total,l);p--;)m.push(+w);p=[];if(3===l)p=findBestSum3(m,b.unbloatedPoints);else if(2===l)p=findBestSum2(m,b.unbloatedPoints);else if(1===l&&b.unbloatedPoints>=m[0])p=findBestSum1(m,b.unbloatedPoints);else{if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};a.push(b);continue}if(0>(b.quriousPoints-=Number(3*p.pop()))){console.log(`${b.name} has ${b.quriousPoints} points}`,b);debugger}v(p,b);a.push(b)}d=(b,r)=>
{b.augs.splice(r,1);r=findBestSum1(Object.keys(e).filter(n=>n<=b.quriousPoints),~~(b.quriousPoints/3));b.quriousPoints-=3*r[1];v([r[0]],b)};if(0<t)for(const b of a)if(!(4<b.innateSkills.length&&Object.entries(e).filter(r=>Object.keys(r[1]).some(n=>b.innateSkills.has(n))))){if(!Object.keys(e).length)break;for(w=b.augs.length-1;--w;)b.augs.some(r=>r["-Def"])&&b.quriousPoints-5>=3*Object.keys(e)[0]?(b.quriousPoints-=5,d(b,w)):b.augs.some(r=>r["-Skill"])&&3*Object.keys(e)[0]<=b.quriousPoints-10&&(b.quriousPoints-=
10,d(b,w))}if(Object.keys(e).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};d=[0,0,0,0,0];let D={};for(let b of a){if(5>b.quriousPoints||!b.fodderCount)continue;const r=Math.min(b.fodderCount,~~(b.quriousPoints/5));Object.keys(b.skills).forEach(n=>{D[n]=D[n]?D[n]+(g[n]?Math.min(c[n].max-g[n],r):r):g[n]?Math.min(c[n].max-g[n],r):r});if(!(4<b.innateSkills||8>b.quriousPoints))for(w=b.augs.length,l=b.skillsRemovedCount,y=b.quriousPoints+0;0<=--w&&!((y-=0<=--l?5:10)<3*w);)for(u=~~(y/
w/3);u--;)++d[u]}return{quriousAugs:k,returnArmors:a,theseExtraPoints:d,newSkills:D,arr:!t}},combineDecos=(a,d)=>{const [...c]=d;a.forEach(g=>{c[0]+=g[0];c[1]+=g[1];c[2]+=g[2];c[3]+=g[3]});return c},max=(a,d)=>a>=d?a:d,getMostSkills=(a,d)=>{for(const c of a){for(a=0;4>a;a++)d.remainingSlots[a]=max(d.remainingSlots[a],c.remainingSlots[a]);for(a=0;5>a;a++)d.quriousSkills[a]=max(d.quriousSkills[a],c.quriousSkills[a]);for(const [g,h]of Object.entries(c.armorSkills))d.armorSkills[g]=max(d.armorSkills[g],
h)}};function sumArmorSkills(a,d){const c={};a.forEach(g=>{Object.entries(g.skills).forEach(([h,k])=>{d[h]&&(c[h]=(c[h]||0)+k)})});return c}
self.addEventListener("message",a=>{var d=[0,0];var c={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var g=[];let h=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const k of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[k[0]],a.data.armors.chest[k[1]],a.data.armors.arm[k[2]],a.data.armors.waist[k[3]],a.data.armors.leg[k[4]]];const e=testThisBatch(a.data);e&&(getMostSkills(e,c),d[1]+=e.length,++d[0],h&&g.push(e));h&&25===g.length&&(--h,postMessage([g,
!1,d]),d=[0,0])}postMessage([g,c,d])});
const testThisBatch=a=>{const {thisWeapon:d,theseCharms:c,requiredSkills:g,skillInfo:h,theseArmors:k,skills:e}=a,l=sumArmorSkills(k,e),t=combineDecos([d,k[0].decos,k[1].decos,k[2].decos,k[3].decos,k[4].decos],a.charmSlots);k.sort((u,m)=>6-u.augs.length-5-(u.skills?.length?Object.keys(u.skills).length:0)-(6-m.augs.length-5-(m.skills?.length?Object.keys(m.skills).length:0)));let y=30;k.forEach(u=>y-=u.augs.length);let v=[];c.forEach(u=>{if(!Object.entries(u).some(([x,f])=>l[x]&&l[x]+f>h[x].max)){var m=
[],p=-t[3],w=-t[0];for(let [x,f]of g){l[x]&&(f+=l[x]);u[x]&&(f+=u[x]);const {lvl:q,lvl4:E}=h[x];if(1!==q&&0!==E||1===q&&(w-=f)>=E)p-=~~(f/E);1===q&&(w-=f);0>f&&m.push([x,f])}if(0<p){let x=[];k.forEach(f=>{let q={totalGain:0,lvl4:0};if(5-Object.keys(f.skills).length<6-f.augs.length){let z=f.augs[3]?-f.augs[3]["+Slots"]/6:0;Object.entries(f.decoAugments).forEach(([B,[F,H]])=>{let I=3>B?f.quriousPoints+(5*(3<f.fodderCount?Math.min(2,f.fodderCount-3):0)+10):f.quriousPoints+(5*(3<f.fodderCount?Math.min(1,
f.fodderCount-3):0)+5);6<B||B<=z||(q.lvl4+=4===F?1:0)>p||6*B>I||(q.totalGain+=12,F=q.totalGain/(B-z),F>q.score&&(q.key=B,q.pointsUsed=B-z,q.score=F,q.thisAugment=H,q.previousSlotAugmentLevel=z))})}let E=z=>{const B=f.fodderCount>z?10:5;f.augs.push(5===B?{"-Def":5}:{"-Skill":10});0>(f.quriousPoints+=B)&&E(z+1)};if(q.key){0>(f.quriousPoints-=6*q.pointsUsed)&&E(3);for(var A=0;4>A;++A)t[A]+=f.decoAugments[q.key][1][A]-f.decos[A],3===A&&(p-=f.decoAugments[q.key][1][A]-f.decos[A]);f.decos=f.decoAugments[q.key][1];
0<q.previousSlotAugmentLevel&&0<q.pointsUsed&&(f.augs[3]["+Slots"]=-18,q.pointsUsed-=3-q.previousSlotAugmentLevel);for(A=q.pointsUsed;0<A;)f.augs.push({"+Slots":Math.min(A,3)}),A-=3;x.push(q)}})}k.forEach(x=>{var f=5-Object.keys(x.skills).length,q=6-x.augs.length;if(!(f>=q)){f=q-f+1;var E=~~(~~(x.quriousPoints/3)/q);if(4<=E){let A=5<=E?0:m.length;for(;5<=E?A++<m.length:0<A--;){let [z,B]=m[A];q=0;if(3<=h[z].qurious&&!h[z].lvl4){B<=-f&&x.quriousPoints>=h[z].qurious*f*3?(q=f,x.quriousPoints-=3*h[z].qurious):
x.skills[z]&&(q=Math.min(-B,f),x.quriousPoints-=h[z].qurious*q*3);for(f=0;f<m.length;f++)if(m[f][0]===z){0===(m[f][1]+=q)&&m.splice(f,1);break}for(x.skills[z]=q;q--;)x.augs.push({"+Skill":z});break}}}}});var [D,b]=getDecos(t.slice(0),m,h,y,w);if(!D.check)return!1;var {quriousAugs:r,returnArmors:n,theseExtraPoints:C,newSkills:G,arr:J}=getQuriousSkills(D,k,h,e);if(!J)return!1;if(n.some(x=>void 0==x.name)){debugger;console.log(n)}v.push({usedSkills:[].concat(r,Object.entries(l),Object.entries(u)),armors:[[n[0].name,
n[0]],[n[1].name,n[1]],[n[2].name,n[2]],[n[3].name,n[3]],[n[4]?.name,n[4]]],remainingSlots:b,quriousSkills:C,armorSkills:G,thisCharm:u})}});v=v.filter(u=>{let m={};u.usedSkills.forEach(p=>{let w=p[3]?p[1]*p[3]:p[1];m[p[0]]=m[p[0]]?m[p[0]]+w:w});if(a.requiredSkills.every(p=>m[p[0]]+=0<=p[1]))return!0;console.log({set:u,ugh:m,skills:e});debugger});if(v[0]){const u=["helm","chest","arm","waist","leg"];[...v]=v.map(m=>{m.armors.sort((p,w)=>u.indexOf(p[1]?.type)-u.indexOf(w[1]?.type));return m});return v}return!1};

const getDecos=([...a],e,c,f,l)=>{const d={remainingSkills:{}};d.decosUsed=f;(()=>{for(let n=0;n<e.length&&0<a[3];n++){const h=c[e[n][0]].lvl4;if(0!==h&&e[n][1]<=-h&&(1!==c[e[n][0]].lvl||0<=(l-=h))){const u=~~Math.min(a[3],-e[n][1]/h);a[3]-=u;e[n][1]+=h*u;d.decosUsed.push([e[n][0],h,"Slot lvl4",u])}}})();((n=-1)=>{for(let [m,r]of e){++n;if(0<=r)continue;let q;switch(c[m].lvl){case 1:q=Math.min(-r,a[0]);break;case 2:q=Math.min(-r,a[1]+a[2]+a[3]);break;case 3:q=Math.min(-r,a[2]+a[3]);break;case 4:q=
Math.min(-r,a[3]);break;default:q=0}if(0>q+r){var h=c[m].qurious,u=q+r;d.remainingSkills[h]||(d.remainingSkills[h]={total:0});d.remainingSkills[h][m]=0;d.remainingSkills[h].total-=u;d.remainingSkills[h][m]-=u;if(!q)continue}for(h=c[m].lvl-2;4>h++&&(!a[h]||(u=Math.min(q,a[h],-e[n][1]),a[h]-=u,e[n][1]+=u,d.decosUsed.push([m,1,`Slot lvl${h+1}`,u]),0!==e[n][1])););}return f})();return[d,a]};
function generateAugmentCombinations(a,e,c,f){a:for(let l=0;l<c.length;l++){const d=c[l];for(let n=l+1;n<c.length;n++){const h=c[n];for(let u=n+1;u<c.length;u++){const m=c[u];let r=3;const q=[];if(d+h+m>f)continue;let p={[d]:1};p[h]=(p[h]||0)+1;p[m]=(p[m]||0)+1;b:for(let w=0,b=Object.entries(p);w<b.length;++w){c:for(let [g,k]of Object.entries(a[b[w][0]]))if("total"!==g)if(e.has(g)){for(r+=k;k++&&r--;)q.push(g);if(0===k)break b}else if(1<k){if(0>=(r+=k))break b;if(0>=(b[w][1]+=k-1))break c}if(!(0<
r)&&(previousBestSolution=[q,d+h+m],d+h+m===f))break a}}}}return previousBestSolution}
const findBestSum3=(a,e)=>{for(let c=0,f=1,l=2,d=a.length;l<d;c++,f++,l++)if(!(a[c]+a[f]+a[l]<e))return a[c]+a[f]+a[l]===e||0===c||a[--c]+a[f]+a[l]<=e||a[c]+a[--f]+a[l]<=e?[a[c],a[f],a[l],a[c]+a[f]+a[l]]:[a[c],a[f],a[l-1],a[c]+a[f]+a[l-1]];return[a[a.length-3],a[a.length-2],a[a.length-1],a[a.length-3]+a[a.length-2]+a[a.length-1]]},findBestSum2=(a,e)=>{for(let c=0,f=1;f<a.length;c++,f++)if(!(a[c]+a[f]<e))return a[c]+a[f]===e||0===c||a[--c]+a[f]<=e?[a[c],a[f],a[c]+a[f]]:[a[c],a[f-1],a[c]+a[f-1]];return[a[a.length-
2],a[a.length-1],a[a.length-2]+a[a.length-1]]},findBestSum1=(a,e)=>{a=a.filter(c=>c<=e).pop();return[a,a]},getQuriousSkills=(a,e,c,f)=>{let {decosUsed:l,remainingSkills:d}=a,n=a=0;for(var h in d)n+=d[h].total;h=b=>{let g=0;0<b.fodderSkills.length&&(++g,++b.skillsRemovedCount);const k=5*(1+g);b.augs.push({[g?"-Skill":"-Def"]:[g?b.fodderSkills.pop():k]});l.push([g?b.fodderSkills.pop():k,g?"-Skill":"-Def",b.name,1]);b.quriousPoints+=k;b.unBloatedPoints=~~(b.quriousPoints/3)};for(var u=0;u<e.length;u++){var m=
e[u];if(0>=n)continue;a=6-m.augs.length;if(n<a)for(;a>n;)h(m),--a;if(1>a)continue;var r=a,q=1;let b=0,g=0,k=Object.keys(d);for(;r--;)g+=+k[b],r&&++q>d[k[b]].total&&(q=1,++b);if(m.unBloatedPoints<g&&(--a,h(m),m.unBloatedPoints<(g-=k[b])&&(--a,h(m),0===q-1&&--b,m.unBloatedPoints<g-k[b]))){--a;continue}r=[];for(var p in d)for(q=Math.min(d[p].total,a);q--;)r.push(+p);q=[];if(3===a)q=findBestSum3(r,m.unBloatedPoints);else if(2===a)q=findBestSum2(r,m.unBloatedPoints);else if(1===a&&m.unBloatedPoints>=r[0])q=
findBestSum1(r,m.unBloatedPoints);else continue;if(0>(m.quriousPoints-=Number(3*q.pop()))){console.log(`${m.name} has ${m.quriousPoints} points}`,m);debugger}((z,C)=>{for(const E of z){z=d[E];let v=Object.keys(z)[1];if(5===C.innateSkills.size)for(let A=1,D=Object.keys(z);A<D.length;A++){if(d[D[A]]){v=D[A];break}if(A===D.length-1)return}C.augs.push({"+Skill":v});l.push([v,1,C.name,1]);C.innateSkills.add(v);0===--z.total?delete d[E]:0===--z[v]&&delete d[E][v];--n}})(q,m)}p=(b,g)=>{b.augs.splice(g,1);
g=findBestSum1(Object.keys(d).filter(k=>k<=b.quriousPoints),~~(b.quriousPoints/3));b.quriousPoints-=3*g[1];pushAugs([g[0]],b)};if(0<n)for(const b of e)if(!(4<b.innateSkills.size&&Object.entries(d).filter(g=>Object.keys(g[1]).some(k=>b.innateSkills.has(k))))){if(!Object.keys(d).length)break;for(a=b.augs.length-1;--a;)b.augs.some(g=>g["-Def"])&&b.quriousPoints-5>=3*+Object.keys(d)[0]?(b.quriousPoints-=5,p(b,a)):b.augs.some(g=>g["-Skill"])&&3*+Object.keys(d)[0]<=b.quriousPoints-10&&(b.quriousPoints-=
10,p(b,a))}if(Object.keys(d).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};p=[0,0,0,0,0];let w={};for(let b of e){if(5>b.quriousPoints||!b.fodderCount)continue;const g=Math.min(b.fodderCount,~~(b.quriousPoints/5));Object.keys(b.skills).forEach(k=>{w[k]=w[k]?w[k]+(f[k]?Math.min(c[k].max-f[k],g):g):f[k]?Math.min(c[k].max-f[k],g):g});if(!(4<b.innateSkills.size||8>b.quriousPoints))for(a=b.augs.length,h=3-b.skillsRemovedCount,u=b.quriousPoints+0;0<=--a&&!((u-=0<=--h?5:10)<3*a);)for(m=
~~(u/a/3);m--;)++p[m]}return{quriousAugs:l,armorPieces:e,theseExtraPoints:p,newSkills:w,arr:!n}},combineDecos=(a,e)=>{const [...c]=e;a.forEach(f=>{c[0]+=f[0];c[1]+=f[1];c[2]+=f[2];c[3]+=f[3]});return c},max=(a,e)=>a>=e?a:e,getMostSkills=(a,e)=>{for(const c of a){for(a=0;4>a;a++)e.remainingSlots[a]=max(e.remainingSlots[a],c.remainingSlots[a]);for(a=0;5>a;a++)e.quriousSkills[a]=max(e.quriousSkills[a],c.quriousSkills[a]);for(const [f,l]of Object.entries(c.armorSkills))e.armorSkills[f]=max(e.armorSkills[f],
l)}};function sumArmorSkills(a,e){const c={};a.forEach(f=>{Object.entries(f.skills).forEach(([l,d])=>{e[l]&&(c[l]=(c[l]||0)+d)})});return c}
self.addEventListener("message",a=>{var e=[0,0];var c={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var f=[];let l=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const d of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[d[0]],a.data.armors.chest[d[1]],a.data.armors.arm[d[2]],a.data.armors.waist[d[3]],a.data.armors.leg[d[4]]];const n=testThisBatch(a.data);n&&(getMostSkills(n,c),e[1]+=n.length,++e[0],l&&f.push(n));l&&25===f.length&&(--l,postMessage([f,
!1,e]),e=[0,0])}postMessage([f,c,e])});
const testThisBatch=a=>{const {thisWeapon:e,theseCharms:c,requiredSkills:f,skillInfo:l,theseArmors:d,skills:n}=a,h=sumArmorSkills(d,n),u=combineDecos([e,d[0].decos,d[1].decos,d[2].decos,d[3].decos,d[4].decos],a.charmSlots);let m=[];c.forEach(r=>{if(!Object.entries(r).some(([t,y])=>h[t]&&h[t]+y>l[t].max)){var q=[],p=[],w=-u[0];for(let [t,y]of f){h[t]&&(y+=h[t]);r[t]&&(y+=r[t]);const {lvl:F,max:J}=l[t];if(y>J)return;1===F&&(w-=y);0>y&&p.push([t,y])}var b=[];for(var g=0;g<d.length;g++){var k={...d[g]};
k.augs=[...d[g].augs];k.fodderSkills=[...d[g].fodderSkills];k.skillsRemovedCount=Math.min(3,d[g].fodderCount);k.innateSkills=new Set(Object.keys(d[g].skills));b.push(k)}a:for(let t=0,y=b.length;t<y;t++){g=5-b[t].innateSkills.size;k=6-b[t].augs.length;if(g>=k)continue;let F=~~(b[t].quriousPoints/3);g=k-g;let J=~~(F/k);k=([x,B],H,G=-1)=>{if(!(l[x].qurious<J||l[x].qurious*H>F)){if(-1===G)for(let I=0;I<p.length;I++)if(p[I][0]===x){G=I;break}if(B<=-H&&F>=l[x].qurious*H){B=Math.min(-B,H);b[t].quriousPoints-=
l[x].qurious*B*3;b[t].unBloatedPoints=~~(b[t].quriousPoints/3);0<=(p[G][1]+=B)&&p.splice(G,1);b[t].innateSkills.add(x);for(q.push([x,1,b[t].name,B]);B--;)b[t].augs.push({"+Skill":x});return!0}}};for(let x of b[t].innateSkills.entries())if(h[x]&&k(x,g))continue a;let K=p.length;for(;--K;)if(k(p[K],g+1,K))continue a}var [z,C]=getDecos(u.slice(0),p,l,q,w),{quriousAugs:E,armorPieces:v,theseExtraPoints:A,newSkills:D,arr:L}=getQuriousSkills(z,b,l,n);if(!L)return!1;if(v.some(t=>void 0==t.name)){debugger;
console.log(v)}m.push({usedSkills:[].concat(E,Object.entries(h),Object.entries(r)),armors:[[v[0].name,v[0]],[v[1].name,v[1]],[v[2].name,v[2]],[v[3].name,v[3]],[v[4]?.name,v[4]]],remainingSlots:C,quriousSkills:A,armorSkills:D,thisCharm:r,decoArr:u})}});m=m.filter(r=>{let q={};r.usedSkills.forEach(p=>{let w=p[3]?p[1]*p[3]:p[1];q[p[0]]=q[p[0]]?q[p[0]]+w:w});if(a.requiredSkills.every(p=>q[p[0]]+=0<=p[1]))return!0;console.log({set:r,ugh:q,skills:n});debugger});if(m[0])return m};

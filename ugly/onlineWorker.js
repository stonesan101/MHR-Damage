const getDecos=([...a],d,e,m,k)=>{const f={remainingSkills:{},decosUsed:[]};(()=>{for(let c=0;c<d.length&&a[3];c++){const h=e[d[c][0]].lvl4;if(0!==h&&d[c][1]<=-1*h&&(1!==e[d[c][0]].lvl||0<=(k-=h))){const t=~~Math.min(a[3],-1*d[c][1]/h);a[3]-=t;d[c][1]+=h*t;f.decosUsed.push([d[c][0],h,"Slot lvl4",t])}}})();f.check=(()=>{for(const [t,y]of d){if(!y||20===e[t].querious)continue;let v;switch(e[t].lvl){case 1:v=Math.min(-1*y,a[0]);break;case 2:v=Math.min(-1*y,a[1]+a[2]+a[3]);break;case 3:v=Math.min(-1*
y,a[2]+a[3]);break;default:v=Math.min(-1*y,a[3])}if(0>v+y){var c=e[t].qurious,h=v+y;f.remainingSkills[c]||(f.remainingSkills[c]={total:0});if(3<=c&&0>(m+=h)||3>c&&0>(m+=h/1.25))return!1;for(f.remainingSkills[c][t]=0;h++;)++f.remainingSkills[c].total,++f.remainingSkills[c][t];if(!v)continue}for(c=e[t].lvl-2;4>c++&&(!a[c]||(h=Math.min(v,a[c]),a[c]-=h,f.decosUsed.push([t,1,`Slot lvl${c+1}`,h]),0!==y+h)););}return m})();return[f,a]};
function generateAugmentCombinations(a,d,e,m){let k=[];a:for(let f=0;f<e.length;f++){const c=e[f];for(let h=f+1;h<e.length;h++){const t=e[h];for(let y=h+1;y<e.length;y++){const v=e[y];let u=3-(5-d.size);if(c+t+v>m)break a;let l={a:1};l[t]?++l[t]:l[t]=1;l[v]?++l[v]:l[v]=1;b:for(let p=0,w=Object.entries(l).length;p<w.length&&0<w;++p)c:for(const [D,b]of Object.entries(a[w[p][0]]))if("total"!==D)if(d.has(D)){if(0>=(u+=b))break b;if(0>=(w[p][1]+=b))break c}else if(1<b){if(0>=(u+=b))break b;if(0>=(w[p][1]+=
b-1))break c}if(!(0<u)&&(c+t+v<m&&(k=[c,t,v]),c+t+v>m))break a}}}return[k,k.reduce((f,c)=>f+c)]}
const findBestSum3=(a,d,e,m)=>{for(let k=0,f=1,c=2,h=a.length;c<h;k++,f++,c++)if(!(a[k]+a[f]+a[c]<d))return a[k]+a[f]+a[c]===d||0===k||a[--k]+a[f]+a[c]<=d||a[k]+a[--f]+a[c]<=d?[a[k],a[f],a[c],a[k]+a[f]+a[c]]:[a[k],a[f],a[c-1],a[k]+a[f]+a[c-1]];return[a[a.length-3],a[a.length-2],a[a.length-1],a[a.length-3]+a[a.length-2]+a[a.length-1]]},findBestSum2=(a,d)=>{for(let e=0,m=1;m<a.length;e++,m++)if(!(a[e]+a[m]<d))return a[e]+a[m]===d||0===e||a[--e]+a[m]<=d?[a[e],a[m],a[e]+a[m]]:[a[e],a[m-1],a[e]+a[m-1]];
return[a[a.length-2],a[a.length-1],a[a.length-2]+a[a.length-1]]},findBestSum1=(a,d)=>{a=a.filter(e=>e<=d).pop();return[a,a]},getQuriousSkills=(a,d,e,m)=>{let {check:k,decosUsed:f,remainingSkills:c}=a;k+=5;var h=0;a=[];let t=0;for(var y of Object.values(c))t+=y.total?y.total:0;y=b=>{let r=0;0<b.fodderSkills.length&&(++r,++b.skillsRemovedCount);const n=5*(1+r);b.augs.push({[r?"-Skill":"-Def"]:[r?b.fodderSkills.pop():n]});f.push([r?b.fodderSkills.pop():n,r?"-Skill":"-Def",b.name,1]);b.quriousPoints+=
n;b.unbloatedPoints=~~(b.quriousPoints/3)};const v=(b,r)=>{for(const n of b){if(4<r.innateSkills.size&&!Object.keys(c[n]).some(G=>r.innateSkills.has(G)))break;b=c[n];const C=Object.keys(b)[1];r.augs.push({"+Skill":C});f.push([C,1,r.name,1]);r.innateSkills.add(C);0===--b.total?delete c[n]:0===--b[C]&&delete b[C];--t}};for(var u=0;u<d.length;u++){let b={};b={...d[u]};b.augs=[...d[u].augs];b.fodderSkills=[...d[u].fodderSkills];b.skillsRemovedCount=Math.min(3,d[u].fodderCount);b.innateSkills=new Set(Object.keys(d[u].skills));
if(0>=t){a.push(b);continue}h=6-b.augs.length;if(t<h)for(;h>t;)y(b),--h;if(1>h){a.push(b);continue}var l=h,p=0;let r=0,n=0,C=Object.keys(c);for(;l--;)n+=+C[r],l&&++p>=c[C[r]].total&&(p=0,++r);if(b.unbloatedPoints<n){if(0>--k)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--h;y(b);if(b.unbloatedPoints<(n-=C[r])){if(0>--k)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--h;y(b);p||--r;if(b.unbloatedPoints<n-C[r]){if(0>--k)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,
arr:!1};--h;a.push(b);continue}}}l=[];for(var w in c)for(p=Math.min(c[w].total,h);p--;)l.push(+w);p=[];if(3===h)p=findBestSum3(l,b.unbloatedPoints);else if(2===h)p=findBestSum2(l,b.unbloatedPoints);else if(1===h&&b.unbloatedPoints>=l[0])p=findBestSum1(l,b.unbloatedPoints);else{if(0>--k)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};a.push(b);continue}if(0>(b.quriousPoints-=Number(3*p.pop()))){console.log(`${b.name} has ${b.quriousPoints} points}`,b);debugger}v(p,b);a.push(b)}d=(b,r)=>
{b.augs.splice(r,1);r=findBestSum1(Object.keys(c).filter(n=>n<=b.quriousPoints),~~(b.quriousPoints/3));b.quriousPoints-=3*r[1];v([r[0]],b)};if(0<t)for(const b of a)if(!(4<b.innateSkills.length&&Object.entries(c).filter(r=>Object.keys(r[1]).some(n=>b.innateSkills.has(n))))){if(!Object.keys(c).length)break;for(w=b.augs.length-1;--w;)b.augs.some(r=>r["-Def"])&&b.quriousPoints-5>=3*Object.keys(c)[0]?(b.quriousPoints-=5,d(b,w)):b.augs.some(r=>r["-Skill"])&&3*Object.keys(c)[0]<=b.quriousPoints-10&&(b.quriousPoints-=
10,d(b,w))}if(Object.keys(c).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};d=[0,0,0,0,0];let D={};for(let b of a){if(5>b.quriousPoints||!b.fodderCount)continue;const r=Math.min(b.fodderCount,~~(b.quriousPoints/5));Object.keys(b.skills).forEach(n=>{D[n]=D[n]?D[n]+(m[n]?Math.min(e[n].max-m[n],r):r):m[n]?Math.min(e[n].max-m[n],r):r});if(!(4<b.innateSkills||8>b.quriousPoints))for(w=b.augs.length,h=b.skillsRemovedCount,y=b.quriousPoints+0;0<=--w&&!((y-=0<=--h?5:10)<3*w);)for(u=~~(y/
w/3);u--;)++d[u]}return{quriousAugs:f,returnArmors:a,theseExtraPoints:d,newSkills:D,arr:!t}},combineDecos=(a,d)=>{const [...e]=d;a.forEach(m=>{e[0]+=m[0];e[1]+=m[1];e[2]+=m[2];e[3]+=m[3]});return e},max=(a,d)=>a>=d?a:d,getMostSkills=(a,d)=>{for(const e of a){for(a=0;4>a;a++)d.remainingSlots[a]=max(d.remainingSlots[a],e.remainingSlots[a]);for(a=0;5>a;a++)d.quriousSkills[a]=max(d.quriousSkills[a],e.quriousSkills[a]);for(const [m,k]of Object.entries(e.armorSkills))d.armorSkills[m]=max(d.armorSkills[m],
k)}};function sumArmorSkills(a,d){const e={};a.forEach(m=>{Object.entries(m.skills).forEach(([k,f])=>{d[k]&&(e[k]=(e[k]||0)+f)})});return e}
addEventListener("message",a=>{var d=[0,0];var e={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var m=[];let k=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const f of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[f[0]],a.data.armors.chest[f[1]],a.data.armors.arm[f[2]],a.data.armors.waist[f[3]],a.data.armors.leg[f[4]]];const c=testThisBatch(a.data);c&&(getMostSkills(c,e),d[1]+=c.length,++d[0],k&&m.push(c));k&&25===m.length&&(--k,postMessage([m,
!1,d]),d=[0,0])}postMessage([m,e,d])});
const testThisBatch=a=>{const {thisWeapon:d,theseCharms:e,requiredSkills:m,skillInfo:k,theseArmors:f,skills:c}=a,h=sumArmorSkills(f,c),t=combineDecos([d,f[0].decos,f[1].decos,f[2].decos,f[3].decos,f[4].decos],a.charmSlots);f.sort((u,l)=>6-u.augs.length-5-(u.skills?.length?Object.keys(u.skills).length:0)-(6-l.augs.length-5-(l.skills?.length?Object.keys(l.skills).length:0)));let y=30;f.forEach(u=>y-=u.augs.length);let v=[];e.forEach(u=>{if(!Object.entries(u).some(([x,g])=>h[x]&&h[x]+g>k[x].max)){var l=
[],p=-t[3],w=-t[0];for(let [x,g]of m){h[x]&&(g+=h[x]);u[x]&&(g+=u[x]);const {lvl:q,lvl4:E}=k[x];if(1!==q&&0!==E||1===q&&(w-=g)>=E)p-=~~(g/E);1===q&&(w-=g);0>g&&l.push([x,g])}if(0<p){let x=[];f.forEach(g=>{let q={totalGain:0,lvl4:0};if(5-Object.keys(g.skills).length<6-g.augs.length){let z=g.augs[3]?-g.augs[3]["+Slots"]/6:0;Object.entries(g.decoAugments).forEach(([B,[F,H]])=>{let I=3>B?g.quriousPoints+(5*(3<g.fodderCount?Math.min(2,g.fodderCount-3):0)+10):g.quriousPoints+(5*(3<g.fodderCount?Math.min(1,
g.fodderCount-3):0)+5);6<B||B<=z||(q.lvl4+=4===F?1:0)>p||6*B>I||(q.totalGain+=12,F=q.totalGain/(B-z),F>q.score&&(q.key=B,q.pointsUsed=B-z,q.score=F,q.thisAugment=H,q.previousSlotAugmentLevel=z))})}let E=z=>{const B=g.fodderCount>z?10:5;g.augs.push(5===B?{"-Def":5}:{"-Skill":10});0>(g.quriousPoints+=B)&&E(z+1)};if(q.key){0>(g.quriousPoints-=6*q.pointsUsed)&&E(3);for(var A=0;4>A;++A)t[A]+=g.decoAugments[q.key][1][A]-g.decos[A],3===A&&(p-=g.decoAugments[q.key][1][A]-g.decos[A]);g.decos=g.decoAugments[q.key][1];
0<q.previousSlotAugmentLevel&&0<q.pointsUsed&&(g.augs[3]["+Slots"]=-18,q.pointsUsed-=3-q.previousSlotAugmentLevel);for(A=q.pointsUsed;0<A;)g.augs.push({"+Slots":Math.min(A,3)}),A-=3;x.push(q)}})}f.forEach(x=>{var g=5-Object.keys(x.skills).length,q=6-x.augs.length;if(!(g>=q)){g=q-g+1;var E=~~(~~(x.quriousPoints/3)/q);if(4<=E){let A=5<=E?0:l.length;for(;5<=E?A++<l.length:0<A--;){let [z,B]=l[A];q=0;if(3<=k[z].qurious&&!k[z].lvl4){B<=-g&&x.quriousPoints>=k[z].qurious*g*3?(q=g,x.quriousPoints-=3*k[z].qurious):
x.skills[z]&&(q=Math.min(-B,g),x.quriousPoints-=k[z].qurious*q*3);for(g=0;g<l.length;g++)if(l[g][0]===z){0===(l[g][1]+=q)&&l.splice(g,1);break}for(x.skills[z]=q;q--;)x.augs.push({"+Skill":z});break}}}}});var [D,b]=getDecos(t.slice(0),l,k,y,w);if(!D.check)return!1;var {quriousAugs:r,returnArmors:n,theseExtraPoints:C,newSkills:G,arr:J}=getQuriousSkills(D,f,k,c);if(!J)return!1;if(n.some(x=>void 0==x.name)){debugger;console.log(n)}v.push({usedSkills:[].concat(r,Object.entries(h),Object.entries(u)),armors:[[n[0].name,
n[0]],[n[1].name,n[1]],[n[2].name,n[2]],[n[3].name,n[3]],[n[4]?.name,n[4]]],remainingSlots:b,quriousSkills:C,armorSkills:G,thisCharm:u})}});v=v.filter(u=>{let l={};u.usedSkills.forEach(p=>{let w=p[3]?p[1]*p[3]:p[1];l[p[0]]=l[p[0]]?l[p[0]]+w:w});if(a.requiredSkills.every(p=>l[p[0]]+=0<=p[1]))return!0;console.log({set:u,ugh:l,skills:c});debugger});if(v[0]){const u=["helm","chest","arm","waist","leg"];[...v]=v.map(l=>{l.armors.sort((p,w)=>u.indexOf(p[1]?.type)-u.indexOf(w[1]?.type));return l});return v}return!1};

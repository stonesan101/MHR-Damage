const getDecos=([...a],d,c,g,h)=>{const f={remainingSkills:{},decosUsed:[]};(()=>{for(let e=0;e<d.length&&a[3];e++){const k=c[d[e][0]].lvl4;if(0!==k&&d[e][1]<=-1*k&&(1!==c[d[e][0]].lvl||0<=(h-=k))){const p=~~Math.min(a[3],-1*d[e][1]/k);a[3]-=p;d[e][1]+=k*p;f.decosUsed.push([d[e][0],k,"Slot lvl4",p])}}})();f.check=(()=>{for(const [p,u]of d){if(!u||20===c[p].querious)continue;let v;switch(c[p].lvl){case 1:v=Math.min(-1*u,a[0]);break;case 2:v=Math.min(-1*u,a[1]+a[2]+a[3]);break;case 3:v=Math.min(-1*
u,a[2]+a[3]);break;default:v=Math.min(-1*u,a[3])}if(0>v+u){var e=c[p].qurious,k=v+u;f.remainingSkills[e]||(f.remainingSkills[e]={total:0});if(3<=e&&0>(g+=k)||3>e&&0>(g+=k/1.25))return!1;for(f.remainingSkills[e][p]=0;k++;)++f.remainingSkills[e].total,++f.remainingSkills[e][p];if(!v)continue}for(e=c[p].lvl-2;4>e++&&(!a[e]||(k=Math.min(v,a[e]),a[e]-=k,f.decosUsed.push([p,1,`Slot lvl${e+1}`,k]),0!==u+k)););}return g})();return[f,a]};
function generateAugmentCombinations(a,d,c,g){let h=[];a:for(let f=0;f<c.length;f++){const e=c[f];for(let k=f+1;k<c.length;k++){const p=c[k];for(let u=k+1;u<c.length;u++){const v=c[u];let w=3-(5-d.size);if(e+p+v>g)break a;let n={a:1};n[p]?++n[p]:n[p]=1;n[v]?++n[v]:n[v]=1;b:for(let m=0,q=Object.entries(n);m<q.length;++m)c:for(const [y,b]of Object.entries(a[q[m][0]]))if("total"!==y)if(d.has(y)){if(0>=(w+=b))break b;if(0>=(q[m][1]+=b))break c}else if(1<b){if(0>=(w+=b))break b;if(0>=(q[m][1]+=b-1))break c}if(!(0<
w)&&(e+p+v<g&&(h=[e,p,v]),e+p+v>g))break a}}}return[h,h.reduce((f,e)=>f+e)]}
const findBestSum3=(a,d)=>{for(let c=0,g=1,h=2,f=a.length;h<f;c++,g++,h++)if(!(a[c]+a[g]+a[h]<d))return a[c]+a[g]+a[h]===d||0===c||a[--c]+a[g]+a[h]<=d||a[c]+a[--g]+a[h]<=d?[a[c],a[g],a[h],a[c]+a[g]+a[h]]:[a[c],a[g],a[h-1],a[c]+a[g]+a[h-1]];return[a[a.length-3],a[a.length-2],a[a.length-1],a[a.length-3]+a[a.length-2]+a[a.length-1]]},findBestSum2=(a,d)=>{for(let c=0,g=1;g<a.length;c++,g++)if(!(a[c]+a[g]<d))return a[c]+a[g]===d||0===c||a[--c]+a[g]<=d?[a[c],a[g],a[c]+a[g]]:[a[c],a[g-1],a[c]+a[g-1]];return[a[a.length-
2],a[a.length-1],a[a.length-2]+a[a.length-1]]},findBestSum1=(a,d)=>{a=a.filter(c=>c<=d).pop();return[a,a]},getQuriousSkills=(a,d,c,g)=>{let {check:h,decosUsed:f,remainingSkills:e}=a;h+=5;var k=0;a=[];let p=0;for(var u of Object.values(e))p+=u.total?u.total:0;u=b=>{let l=0;0<b.fodderSkills.length&&(++l,++b.skillsRemovedCount);const r=5*(1+l);b.augs.push({[l?"-Skill":"-Def"]:[l?b.fodderSkills.pop():r]});f.push([l?b.fodderSkills.pop():r,l?"-Skill":"-Def",b.name,1]);b.quriousPoints+=r;b.unBloatedPoints=
~~(b.quriousPoints/3)};const v=(b,l)=>{for(const r of b){b=e[r];let x=Object.keys(b)[1];if(5===l.innateSkills.size)for(let C=1,D=Object.keys(b);C<D.length;C++){if(e[D[C]]){x=D[C];break}if(C===D.length-1)return}l.augs.push({"+Skill":x});f.push([x,1,l.name,1]);l.innateSkills.add(x);0===--b.total?delete e[r]:0===--b[x]&&delete e[r][x];--p}};for(var w=0;w<d.length;w++){let b={};b={...d[w]};b.augs=[...d[w].augs];b.fodderSkills=[...d[w].fodderSkills];b.skillsRemovedCount=Math.min(3,d[w].fodderCount);b.innateSkills=
new Set(Object.keys(d[w].skills));if(0>=p){a.push(b);continue}k=6-b.augs.length;if(p<k)for(;k>p;)u(b),--k;if(1>k){a.push(b);continue}var n=k,m=1;let l=0,r=0,x=Object.keys(e);for(;n--;)r+=+x[l],n&&++m>e[x[l]].total&&(m=1,++l);if(b.unBloatedPoints<r){if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--k;u(b);if(b.unBloatedPoints<(r-=x[l])){if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--k;u(b);0===m-1&&--l;if(b.unBloatedPoints<r-x[l]){if(0>--h)return{quriousAugs:0,
finalSkillCheck:0,returnArmors:0,arr:!1};--k;a.push(b);continue}}}n=[];for(var q in e)for(m=Math.min(e[q].total,k);m--;)n.push(+q);m=[];if(3===k)m=findBestSum3(n,b.unBloatedPoints);else if(2===k)m=findBestSum2(n,b.unBloatedPoints);else if(1===k&&b.unBloatedPoints>=n[0])m=findBestSum1(n,b.unBloatedPoints);else{if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};a.push(b);continue}if(0>(b.quriousPoints-=Number(3*m.pop()))){console.log(`${b.name} has ${b.quriousPoints} points}`,b);
debugger}v(m,b);a.push(b)}d=(b,l)=>{b.augs.splice(l,1);l=findBestSum1(Object.keys(e).filter(r=>r<=b.quriousPoints),~~(b.quriousPoints/3));b.quriousPoints-=3*l[1];v([l[0]],b)};if(0<p)for(const b of a)if(!(4<b.innateSkills.length&&Object.entries(e).filter(l=>Object.keys(l[1]).some(r=>b.innateSkills.has(r))))){if(!Object.keys(e).length)break;for(q=b.augs.length-1;--q;)b.augs.some(l=>l["-Def"])&&b.quriousPoints-5>=3*Object.keys(e)[0]?(b.quriousPoints-=5,d(b,q)):b.augs.some(l=>l["-Skill"])&&3*Object.keys(e)[0]<=
b.quriousPoints-10&&(b.quriousPoints-=10,d(b,q))}if(Object.keys(e).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};d=[0,0,0,0,0];let y={};for(let b of a){if(5>b.quriousPoints||!b.fodderCount)continue;const l=Math.min(b.fodderCount,~~(b.quriousPoints/5));Object.keys(b.skills).forEach(r=>{y[r]=y[r]?y[r]+(g[r]?Math.min(c[r].max-g[r],l):l):g[r]?Math.min(c[r].max-g[r],l):l});if(!(4<b.innateSkills||8>b.quriousPoints))for(q=b.augs.length,k=b.skillsRemovedCount,u=b.quriousPoints+0;0<=
--q&&!((u-=0<=--k?5:10)<3*q);)for(w=~~(u/q/3);w--;)++d[w]}return{quriousAugs:f,returnArmors:a,theseExtraPoints:d,newSkills:y,arr:!p}},combineDecos=(a,d)=>{const [...c]=d;a.forEach(g=>{c[0]+=g[0];c[1]+=g[1];c[2]+=g[2];c[3]+=g[3]});return c},max=(a,d)=>a>=d?a:d,getMostSkills=(a,d)=>{for(const c of a){for(a=0;4>a;a++)d.remainingSlots[a]=max(d.remainingSlots[a],c.remainingSlots[a]);for(a=0;5>a;a++)d.quriousSkills[a]=max(d.quriousSkills[a],c.quriousSkills[a]);for(const [g,h]of Object.entries(c.armorSkills))d.armorSkills[g]=
max(d.armorSkills[g],h)}};function sumArmorSkills(a,d){const c={};a.forEach(g=>{Object.entries(g.skills).forEach(([h,f])=>{d[h]&&(c[h]=(c[h]||0)+f)})});return c}
self.addEventListener("message",a=>{var d=[0,0];var c={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var g=[];let h=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const f of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[f[0]],a.data.armors.chest[f[1]],a.data.armors.arm[f[2]],a.data.armors.waist[f[3]],a.data.armors.leg[f[4]]];const e=testThisBatch(a.data);e&&(getMostSkills(e,c),d[1]+=e.length,++d[0],h&&g.push(e));h&&25===g.length&&(--h,postMessage([g,
!1,d]),d=[0,0])}postMessage([g,c,d])});
const testThisBatch=a=>{const {thisWeapon:d,theseCharms:c,requiredSkills:g,skillInfo:h,theseArmors:f,skills:e}=a,k=sumArmorSkills(f,e),p=combineDecos([d,f[0].decos,f[1].decos,f[2].decos,f[3].decos,f[4].decos],a.charmSlots);let u=30;f.forEach(w=>u-=w.augs.length);let v=[];c.forEach(w=>{if(!Object.entries(w).some(([t,A])=>k[t]&&k[t]+A>h[t].max)){var n=[],m=-p[0];for(let [t,A]of g){k[t]&&(A+=k[t]);w[t]&&(A+=w[t]);const {lvl:F,max:B}=h[t];if(A>B)return;1===F&&(m-=A);0>A&&n.push([t,A])}a:for(let t=0,A=
f.length;t<A;t++){var q=5-Object.keys(f[t].skills).length,y=6-f[t].augs.length;if(q>=y)continue;let F=~~(f[t].quriousPoints/3);q=y-q+1;y=~~(F/y);let B=5>y?0:n.length;for(;5>y?++B<n.length:0<--B;){let [z,G]=n[B];if(h[z].lvl4||9>h[z].qurious||h[z].qurious*(k[z]?q-1:q)>F)continue;let E=0;if(!f[t].skills[z]&&G<=-q&&F>=h[z].qurious*q)E=Math.min(-G,q);else if(f[t].skills[z])E=Math.min(-G,q-1);else continue;f[t].quriousPoints-=h[z].qurious*E*3;f[t].unBloatedPoints=~~(f[t].quriousPoints/3);0===(n[B][1]+=
E)&&n.splice(B,1);for(f[t].skills[z]=(f[t].skills[z]||0)+E;E--;)f[t].augs.push({"+Skill":z});continue a}}var [b,l]=getDecos(p.slice(0),n,h,u,m);if(!b.check)return!1;var {quriousAugs:r,returnArmors:x,theseExtraPoints:C,newSkills:D,arr:H}=getQuriousSkills(b,f,h,e);if(!H)return!1;if(x.some(t=>void 0==t.name)){debugger;console.log(x)}v.push({usedSkills:[].concat(r,Object.entries(k),Object.entries(w)),armors:[[x[0].name,x[0]],[x[1].name,x[1]],[x[2].name,x[2]],[x[3].name,x[3]],[x[4]?.name,x[4]]],remainingSlots:l,
quriousSkills:C,armorSkills:D,thisCharm:w})}});v=v.filter(w=>{let n={};w.usedSkills.forEach(m=>{let q=m[3]?m[1]*m[3]:m[1];n[m[0]]=n[m[0]]?n[m[0]]+q:q});if(a.requiredSkills.every(m=>n[m[0]]+=0<=m[1]))return!0;console.log({set:w,ugh:n,skills:e});debugger});if(v[0])return v};

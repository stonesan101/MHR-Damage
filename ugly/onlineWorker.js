const getDecos=([...a],d,c,g,h)=>{const f={remainingSkills:{},decosUsed:[]};(()=>{for(let e=0;e<d.length&&a[3];e++){const k=c[d[e][0]].lvl4;if(0!==k&&d[e][1]<=-1*k&&(1!==c[d[e][0]].lvl||0<=(h-=k))){const r=~~Math.min(a[3],-1*d[e][1]/k);a[3]-=r;d[e][1]+=k*r;f.decosUsed.push([d[e][0],k,"Slot lvl4",r])}}})();f.check=(()=>{for(const [r,w]of d){if(!w||20===c[r].querious)continue;let u;switch(c[r].lvl){case 1:u=Math.min(-1*w,a[0]);break;case 2:u=Math.min(-1*w,a[1]+a[2]+a[3]);break;case 3:u=Math.min(-1*
w,a[2]+a[3]);break;default:u=Math.min(-1*w,a[3])}if(0>u+w){var e=c[r].qurious,k=u+w;f.remainingSkills[e]||(f.remainingSkills[e]={total:0});if(3<=e&&0>(g+=k)||3>e&&0>(g+=k/1.25))return!1;for(f.remainingSkills[e][r]=0;k++;)++f.remainingSkills[e].total,++f.remainingSkills[e][r];if(!u)continue}for(e=c[r].lvl-2;4>e++&&(!a[e]||(k=Math.min(u,a[e]),a[e]-=k,f.decosUsed.push([r,1,`Slot lvl${e+1}`,k]),0!==w+k)););}return g})();return[f,a]};
function generateAugmentCombinations(a,d,c,g){let h=[];a:for(let f=0;f<c.length;f++){const e=c[f];for(let k=f+1;k<c.length;k++){const r=c[k];for(let w=k+1;w<c.length;w++){const u=c[w];let p=3-(5-d.size);if(e+r+u>g)break a;let l={a:1};l[r]?++l[r]:l[r]=1;l[u]?++l[u]:l[u]=1;b:for(let m=0,q=Object.entries(l);m<q.length;++m)c:for(const [y,b]of Object.entries(a[q[m][0]]))if("total"!==y)if(d.has(y)){if(0>=(p+=b))break b;if(0>=(q[m][1]+=b))break c}else if(1<b){if(0>=(p+=b))break b;if(0>=(q[m][1]+=b-1))break c}if(!(0<
p)&&(e+r+u<g&&(h=[e,r,u]),e+r+u>g))break a}}}return[h,h.reduce((f,e)=>f+e)]}
const findBestSum3=(a,d)=>{for(let c=0,g=1,h=2,f=a.length;h<f;c++,g++,h++)if(!(a[c]+a[g]+a[h]<d))return a[c]+a[g]+a[h]===d||0===c||a[--c]+a[g]+a[h]<=d||a[c]+a[--g]+a[h]<=d?[a[c],a[g],a[h],a[c]+a[g]+a[h]]:[a[c],a[g],a[h-1],a[c]+a[g]+a[h-1]];return[a[a.length-3],a[a.length-2],a[a.length-1],a[a.length-3]+a[a.length-2]+a[a.length-1]]},findBestSum2=(a,d)=>{for(let c=0,g=1;g<a.length;c++,g++)if(!(a[c]+a[g]<d))return a[c]+a[g]===d||0===c||a[--c]+a[g]<=d?[a[c],a[g],a[c]+a[g]]:[a[c],a[g-1],a[c]+a[g-1]];return[a[a.length-
2],a[a.length-1],a[a.length-2]+a[a.length-1]]},findBestSum1=(a,d)=>{a=a.filter(c=>c<=d).pop();return[a,a]},getQuriousSkills=(a,d,c,g)=>{let {check:h,decosUsed:f,remainingSkills:e}=a;h+=5;var k=0;a=[];let r=0;for(var w of Object.values(e))r+=w.total?w.total:0;w=b=>{let n=0;0<b.fodderSkills.length&&(++n,++b.skillsRemovedCount);const t=5*(1+n);b.augs.push({[n?"-Skill":"-Def"]:[n?b.fodderSkills.pop():t]});f.push([n?b.fodderSkills.pop():t,n?"-Skill":"-Def",b.name,1]);b.quriousPoints+=t;b.unBloatedPoints=
~~(b.quriousPoints/3)};const u=(b,n)=>{for(const t of b){b=e[t];let x=Object.keys(b)[1];if(5===n.innateSkills.size)for(let C=1,D=Object.keys(b);C<D.length;C++){if(e[D[C]]){x=D[C];break}if(C===D.length-1)return}n.augs.push({"+Skill":x});f.push([x,1,n.name,1]);n.innateSkills.add(x);0===--b.total?delete e[t]:0===--b[x]&&delete e[t][x];--r}};for(var p=0;p<d.length;p++){let b={};b={...d[p]};b.augs=[...d[p].augs];b.fodderSkills=[...d[p].fodderSkills];b.skillsRemovedCount=Math.min(3,d[p].fodderCount);b.innateSkills=
new Set(Object.keys(d[p].skills));if(0>=r){a.push(b);continue}k=6-b.augs.length;if(r<k)for(;k>r;)w(b),--k;if(1>k){a.push(b);continue}var l=k,m=1;let n=0,t=0,x=Object.keys(e);for(;l--;)t+=+x[n],l&&++m>e[x[n]].total&&(m=1,++n);if(b.unBloatedPoints<t){if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--k;w(b);if(b.unBloatedPoints<(t-=x[n])){if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--k;w(b);0===m-1&&--n;if(b.unBloatedPoints<t-x[n]){if(0>--h)return{quriousAugs:0,
finalSkillCheck:0,returnArmors:0,arr:!1};--k;a.push(b);continue}}}l=[];for(var q in e)for(m=Math.min(e[q].total,k);m--;)l.push(+q);m=[];if(3===k)m=findBestSum3(l,b.unBloatedPoints);else if(2===k)m=findBestSum2(l,b.unBloatedPoints);else if(1===k&&b.unBloatedPoints>=l[0])m=findBestSum1(l,b.unBloatedPoints);else{if(0>--h)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};a.push(b);continue}if(0>(b.quriousPoints-=Number(3*m.pop()))){console.log(`${b.name} has ${b.quriousPoints} points}`,b);
debugger}u(m,b);a.push(b)}d=(b,n)=>{b.augs.splice(n,1);n=findBestSum1(Object.keys(e).filter(t=>t<=b.quriousPoints),~~(b.quriousPoints/3));b.quriousPoints-=3*n[1];u([n[0]],b)};if(0<r)for(const b of a)if(!(4<b.innateSkills.length&&Object.entries(e).filter(n=>Object.keys(n[1]).some(t=>b.innateSkills.has(t))))){if(!Object.keys(e).length)break;for(q=b.augs.length-1;--q;)b.augs.some(n=>n["-Def"])&&b.quriousPoints-5>=3*Object.keys(e)[0]?(b.quriousPoints-=5,d(b,q)):b.augs.some(n=>n["-Skill"])&&3*Object.keys(e)[0]<=
b.quriousPoints-10&&(b.quriousPoints-=10,d(b,q))}if(Object.keys(e).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};d=[0,0,0,0,0];let y={};for(let b of a){if(5>b.quriousPoints||!b.fodderCount)continue;const n=Math.min(b.fodderCount,~~(b.quriousPoints/5));Object.keys(b.skills).forEach(t=>{y[t]=y[t]?y[t]+(g[t]?Math.min(c[t].max-g[t],n):n):g[t]?Math.min(c[t].max-g[t],n):n});if(!(4<b.innateSkills||8>b.quriousPoints))for(q=b.augs.length,k=b.skillsRemovedCount,w=b.quriousPoints+0;0<=
--q&&!((w-=0<=--k?5:10)<3*q);)for(p=~~(w/q/3);p--;)++d[p]}return{quriousAugs:f,returnArmors:a,theseExtraPoints:d,newSkills:y,arr:!r}},combineDecos=(a,d)=>{const [...c]=d;a.forEach(g=>{c[0]+=g[0];c[1]+=g[1];c[2]+=g[2];c[3]+=g[3]});return c},max=(a,d)=>a>=d?a:d,getMostSkills=(a,d)=>{for(const c of a){for(a=0;4>a;a++)d.remainingSlots[a]=max(d.remainingSlots[a],c.remainingSlots[a]);for(a=0;5>a;a++)d.quriousSkills[a]=max(d.quriousSkills[a],c.quriousSkills[a]);for(const [g,h]of Object.entries(c.armorSkills))d.armorSkills[g]=
max(d.armorSkills[g],h)}};function sumArmorSkills(a,d){const c={};a.forEach(g=>{Object.entries(g.skills).forEach(([h,f])=>{d[h]&&(c[h]=(c[h]||0)+f)})});return c}
self.addEventListener("message",a=>{var d=[0,0];var c={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var g=[];let h=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const f of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[f[0]],a.data.armors.chest[f[1]],a.data.armors.arm[f[2]],a.data.armors.waist[f[3]],a.data.armors.leg[f[4]]];const e=testThisBatch(a.data);e&&(getMostSkills(e,c),d[1]+=e.length,++d[0],h&&g.push(e));h&&25===g.length&&(--h,postMessage([g,
!1,d]),d=[0,0])}postMessage([g,c,d])});
const testThisBatch=a=>{const {thisWeapon:d,theseCharms:c,requiredSkills:g,skillInfo:h,theseArmors:f,skills:e}=a,k=sumArmorSkills(f,e),r=combineDecos([d,f[0].decos,f[1].decos,f[2].decos,f[3].decos,f[4].decos],a.charmSlots);f.sort((p,l)=>6-p.augs.length-5-(p.skills?.length?Object.keys(p.skills).length:0)-(6-l.augs.length-5-(l.skills?.length?Object.keys(l.skills).length:0)));let w=30;f.forEach(p=>w-=p.augs.length);let u=[];c.forEach(p=>{if(!Object.entries(p).some(([v,A])=>k[v]&&k[v]+A>h[v].max)){var l=
[],m=-r[0];for(let [v,A]of g){k[v]&&(A+=k[v]);p[v]&&(A+=p[v]);const {lvl:F,max:B}=h[v];if(A>B)return;1===F&&(m-=A);0>A&&l.push([v,A])}a:for(let v=0,A=f.length;v<A;v++){var q=5-Object.keys(f[v].skills).length,y=6-f[v].augs.length;if(q>=y)continue;let F=~~(f[v].quriousPoints/3);q=y-q+1;y=~~(F/y);let B=5>y?0:l.length;for(;5>y?++B<l.length:0<--B;){let [z,G]=l[B];if(h[z].lvl4||9>h[z].qurious||h[z].qurious*(k[z]?q-1:q)>F)continue;let E=0;if(!f[v].skills[z]&&G<=-q&&F>=h[z].qurious*q)E=Math.min(-G,q);else if(f[v].skills[z])E=
Math.min(-G,q-1);else continue;f[v].quriousPoints-=h[z].qurious*E*3;f[v].unBloatedPoints=~~(f[v].quriousPoints/3);0===(l[B][1]+=E)&&l.splice(B,1);for(f[v].skills[z]=(f[v].skills[z]||0)+E;E--;)f[v].augs.push({"+Skill":z});continue a}}var [b,n]=getDecos(r.slice(0),l,h,w,m);if(!b.check)return!1;var {quriousAugs:t,returnArmors:x,theseExtraPoints:C,newSkills:D,arr:H}=getQuriousSkills(b,f,h,e);if(!H)return!1;if(x.some(v=>void 0==v.name)){debugger;console.log(x)}u.push({usedSkills:[].concat(t,Object.entries(k),
Object.entries(p)),armors:[[x[0].name,x[0]],[x[1].name,x[1]],[x[2].name,x[2]],[x[3].name,x[3]],[x[4]?.name,x[4]]],remainingSlots:n,quriousSkills:C,armorSkills:D,thisCharm:p})}});u=u.filter(p=>{let l={};p.usedSkills.forEach(m=>{let q=m[3]?m[1]*m[3]:m[1];l[m[0]]=l[m[0]]?l[m[0]]+q:q});if(a.requiredSkills.every(m=>l[m[0]]+=0<=m[1]))return!0;console.log({set:p,ugh:l,skills:e});debugger});if(u[0]){const p=["helm","chest","arm","waist","leg"];[...u]=u.map(l=>{l.armors.sort((m,q)=>p.indexOf(m[1]?.type)-p.indexOf(q[1]?.type));
return l});return u}return!1};

const getDecos=([...a],c,d,b,h)=>{const f={remainingSkills:{}};f.decosUsed=b;for(b=0;b<c.length&&0<a[3];b++){var g=d[c[b][0]].lvl4;if(0!==g&&c[b][1]<=-g&&(1!==d[c[b][0]].lvl||0<=(h-=g))){var e=~~Math.min(a[3],-c[b][1]/g);a[3]-=e;c[b][1]+=g*e;f.decosUsed.push([c[b][0],g,"Slot lvl4",e])}}h=-1;for(let [k,l]of c)if(++h,!(0<=l)){switch(d[k].lvl){case 1:b=Math.min(-l,a[0]);break;case 2:b=Math.min(-l,a[1]+a[2]+a[3]);break;case 3:b=Math.min(-l,a[2]+a[3]);break;case 4:b=Math.min(-l,a[3]);break;default:b=0}if(0>
b+l&&(g=d[k].qurious,e=b+l,f.remainingSkills[g]||(f.remainingSkills[g]={total:0}),f.remainingSkills[g][k]=0,f.remainingSkills[g].total-=e,f.remainingSkills[g][k]-=e,!b))continue;for(g=d[k].lvl-2;4>g++&&(!a[g]||(e=Math.min(b,a[g],-c[h][1]),a[g]-=e,c[h][1]+=e,f.decosUsed.push([k,1,`Slot lvl${g+1}`,e]),0!==c[h][1])););}return[f,a]};
function addSkills(a,c,d,b,h,f){a:for(let [g,e]of Object.entries(b)){for(let k of a.values())if(c[g][k]){b=Math.min(e,c[g][k]);d[0]+=+g*b;f-=b;for(e-=b;b--;)d.push([k,g]);if(!f)break a;if(!e)continue a}for(let [k,l]of Object.entries(c[g]))if(!(2>l)){if(0>--h)break a;b=Math.min(e,l);d[0]+=+g*b;f-=b;for(e-=b;b--;)d.push([k,g]);if(!f)break a;if(!e)continue a}}return d}
function SkillRestrictedCombinations3(a,c,d,b){let h=[0];a=Object.fromEntries(Object.entries(a).map(([g,e])=>[g,Object.fromEntries(Object.entries(e).filter(([k])=>"total"!==k).sort(([,k],[,l])=>l-k))]));for(let g=0;g<d.length;g++){const e=d[g];for(let k=g+1;k<d.length;k++){const l=d[k];for(let n=k+1;n<d.length;n++){var f=d[n];if(e+l+f>b)break;let p={[e]:1};p[l]=(p[l]||0)+1;p[f]=(p[f]||0)+1;f=addSkills(c,a,[0],p,5-c.size,3);f[0]<=b&&f[0]>h[0]&&([...h]=f)}}}return h}
function SkillRestrictedCombinations2(a,c,d,b){let h=[0];a=Object.fromEntries(Object.entries(a).map(([g,e])=>[g,Object.fromEntries(Object.entries(e).filter(([k])=>"total"!==k).sort(([,k],[,l])=>l-k))]));for(let g=0;g<d.length;g++){const e=d[g];for(let k=g+1;k<d.length;k++){var f=d[k];if(e+f>b)break;let l={[e]:1};l[f]=(l[f]||0)+1;f=addSkills(c,a,[0],l,5-c.size,2);f[0]<=b&&f[0]>h[0]&&([...h]=f)}}return h}
const findBestSum3=(a,c)=>{for(let d=0,b=1,h=2,f=a.length;h<f;d++,b++,h++)if(!(a[d]+a[b]+a[h]<c))return a[d]+a[b]+a[h]===c||0===d||a[--d]+a[b]+a[h]<=c||a[d]+a[--b]+a[h]<=c?[a[d],a[b],a[h],a[d]+a[b]+a[h]]:[a[d],a[b],a[h-1],a[d]+a[b]+a[h-1]];c=a.length;return[a[c-3],a[c-2],a[c-1],a[c-3]+a[c-2]+a[c-1]]},findBestSum2=(a,c)=>{for(let d=0,b=1;b<a.length;d++,b++)if(!(a[d]+a[b]<c))return a[d]+a[b]===c||0===d||a[--d]+a[b]<=c?[a[d],a[b],a[d]+a[b]]:a.slice(-2).concat(a.slice(-2).reduce((h,f)=>h+f)[0]);c=a.length;
return[a[c-2],a[c-1],a[c-2]+a[c-1]]},findBestSum1=(a,c)=>{a=a.filter(d=>d<=c).pop();return[a,a]},getPoints=(a,c)=>{let d=0;0<a.fodderSkills.length&&(++d,++a.skillsRemovedCount);const b=5*(1+d);a.augs.push({[d?"-Skill":"-Def"]:[d?a.fodderSkills.pop():b]});c.push([d?a.fodderSkills.pop():b,d?"-Skill":"-Def",a.name,1]);a.quriousPoints+=b;a.unBloatedPoints=~~(a.quriousPoints/3);return[a,c]},pushAugs=(a,c,d,b,h)=>{for(const f of a){let [g,e]=Array.isArray(f)?f:[Object.keys(b[f])[1],f];c.augs.push({"+Skill":g});
h.push([g,1,c.name,1]);c.innateSkills.add(g);0===--b[e].total?delete b[e]:0===--b[e][g]&&delete b[e][g];--d}return d},minimumCostForPossibleAugs=(a,c)=>{let d=0;for(let b=0;a&&b<c.length;++b){let h=Math.min(c[b][1].total,a);d+=h*+c[b][0];a-=h}return d},getQuriousSkills=(a,c,d,b)=>{let {decosUsed:h,remainingSkills:f}=a,g=Object.values(f).reduce((m,q)=>m+q.total,0);if(15<g)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};a=[];for(b=0;b<c.length;b++){var e={...c[b]};e.augs=[...c[b].augs];
e.fodderSkills=[...c[b].fodderSkills];e.skillsRemovedCount=Math.min(3,c[b].fodderCount);e.innateSkills=new Set(Object.keys(c[b].skills));a.push(e);var k=Object.entries(f);if(g&&k.length){for(var l=Math.min(6-e.augs.length,g),n=g<6-e.augs.length?6-e.augs.length-g:0;l&&minimumCostForPossibleAugs(l,k)>e.unBloatedPoints;)++n,--l;if(l){for(;n--;)[e,h]=getPoints(e,h);k=[];for(var p in f)for(n=Math.min(f[p].total,l);n--;)k.push(+p);n=[];if(5-e.innateSkills.size>=l){if(3===l)n=findBestSum3(k,e.unBloatedPoints);
else if(2===l)n=findBestSum2(k,e.unBloatedPoints);else if(1===l&&e.unBloatedPoints>=k[0])n=findBestSum1(k,e.unBloatedPoints);else continue;if(0>(e.quriousPoints-=Number(3*n.pop()))||void 0===e.quriousPoints){console.log(`${e.name} has ${e.quriousPoints} points}`,e);debugger}}else if(3===l?n=SkillRestrictedCombinations3(f,e.innateSkills,k,e.unBloatedPoints):2===l?n=SkillRestrictedCombinations2(f,e.innateSkills,k,e.unBloatedPoints):1===l&&console.log("limit 1"),0>(e.quriousPoints-=Number(3*n.shift()))||
void 0===e.quriousPoints){console.log(`${e.name} has ${e.quriousPoints} points}`,e);debugger}g=pushAugs(n,e,g,f,h)}}}c=(m,q)=>{m.augs.splice(q,1);q=findBestSum1(Object.keys(f).filter(v=>+v<=~~(m.quriousPoints/3)));q[0]&&(m.quriousPoints-=3*q[1],g=pushAugs([q[0]],m,g,f,h))};if(0<g)for(const m of a)if(!(4<m.innateSkills.size&&Object.entries(f).filter(q=>Object.keys(q[1]).every(v=>!m.innateSkills.has(v))))){if(!Object.keys(f).length)break;for(p=m.augs.length-1;--p;)m.augs.some(q=>q["-Def"])&&m.quriousPoints-
5>=3*+Object.keys(f)[0]?(m.quriousPoints-=5,c(m,p)):m.augs.some(q=>q["-Skill"])&&m.quriousPoints-10>=3*+Object.keys(f)[0]&&(m.quriousPoints-=10,c(m,p))}if(Object.keys(f).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};c=[0,0,0,0,0];p={};for(let m of a)if(!(5>m.quriousPoints)&&m.fodderCount){b=Math.min(m.fodderCount,~~(m.quriousPoints/5));for(let [q,v]of Object.entries(m.skills))p[q]=Math.min(d[q]?.max||10,v,b);if(!(4<m.innateSkills.size||8>m.quriousPoints))for(b=m.augs.length,
e=3-m.skillsRemovedCount,l=m.quriousPoints+0;0<=--b&&!((l-=0<=--e?5:10)<3*b);)for(k=~~(l/b/3);k--;)++c[k]}return{quriousAugs:h,armorPieces:a,theseExtraPoints:c,newSkills:p,arr:!g}},combineDecos=(a,c)=>{const [...d]=c;a.forEach(b=>{d[0]+=b[0];d[1]+=b[1];d[2]+=b[2];d[3]+=b[3]});return d},max=(a,c)=>a>=c?a:c,getMostSkills=(a,c)=>{for(const d of a){for(a=0;4>a;a++)c.remainingSlots[a]=max(c.remainingSlots[a],d.remainingSlots[a]);for(a=0;5>a;a++)c.quriousSkills[a]=max(c.quriousSkills[a],d.quriousSkills[a]);
for(const [b,h]of Object.entries(d.armorSkills))c.armorSkills[b]=max(c.armorSkills[b],h)}};
self.addEventListener("message",a=>{var c=[0,0];var d={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var b=[];let h=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const f of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[f[0]],a.data.armors.chest[f[1]],a.data.armors.arm[f[2]],a.data.armors.waist[f[3]],a.data.armors.leg[f[4]]];const g=testThisBatch(a.data);g&&(getMostSkills(g,d),c[1]+=g.length,++c[0],h&&b.push(g));h&&25===b.length&&(--h,postMessage([b,
!1,c]),b.length=0,c=[0,0])}postMessage([b,d,c])});
const testThisBatch=a=>{const {thisWeapon:c,theseCharms:d,requiredSkills:b,skillInfo:h,theseArmors:f,skills:g}=a,e={};for(let n of f)for(let [p,m]of Object.entries(n.skills))g[p]&&(e[p]=(e[p]||0)+m);const k=combineDecos([c,f[0].decos,f[1].decos,f[2].decos,f[3].decos,f[4].decos],a.charmSlots);f.sort((n,p)=>{const m=6-n.augs.length-(10>=(6-n.augs.length)/n.quriousPoints?1:0);n=5-Object.keys(n.skills).length;const q=6-p.augs.length-(10>=(6-p.augs.length)/p.quriousPoints?1:0);p=5-Object.keys(p.skills).length;
return n-m-(p-q)});let l=[];d.forEach(n=>{if(!Object.entries(n).every(([r,u])=>!e[r]||e[r]+u<=h[r].max)){var p=[],m=-k[0];for(let [r,u]of b){e[r]&&(u+=e[r]);n[r]&&(u+=n[r]);const {lvl:w,max:x}=h[r];if(u>x)return;1===w&&(m-=u);0>u&&p.push([r,u])}var [q,v]=getDecos(k.slice(0),p,h,[],m),{quriousAugs:y,armorPieces:t,theseExtraPoints:z,newSkills:A,arr:B}=getQuriousSkills(q,f,h,g);if(!B)return!1;if(t.some(r=>void 0==r.name)){debugger;console.log(t)}l.push({usedSkills:[].concat(y,Object.entries(e),Object.entries(n)),
armors:[[t[0].name,t[0]],[t[1].name,t[1]],[t[2].name,t[2]],[t[3].name,t[3]],[t[4]?.name,t[4]]],remainingSlots:v,quriousSkills:z,armorSkills:A,thisCharm:n,decoArr:k})}});if(l[0]){const n=["helm","chest","arm","waist","leg"];[...l]=l.map(p=>{p.armors.sort((m,q)=>n.indexOf(m[1]?.type)-n.indexOf(q[1]?.type));return p});return l}};

const getDecos=([...a],e,c,g,l)=>{const d={remainingSkills:{}};d.decosUsed=g;(()=>{for(let n=0;n<e.length&&0<a[3];n++){const h=c[e[n][0]].lvl4;if(0!==h&&e[n][1]<=-h&&(1!==c[e[n][0]].lvl||0<=(l-=h))){const v=~~Math.min(a[3],-e[n][1]/h);a[3]-=v;e[n][1]+=h*v;d.decosUsed.push([e[n][0],h,"Slot lvl4",v])}}})();((n=-1)=>{for(let [r,k]of e){++n;if(0<=k)continue;let p;switch(c[r].lvl){case 1:p=Math.min(-k,a[0]);break;case 2:p=Math.min(-k,a[1]+a[2]+a[3]);break;case 3:p=Math.min(-k,a[2]+a[3]);break;case 4:p=
Math.min(-k,a[3]);break;default:p=0}if(0>p+k){var h=c[r].qurious,v=p+k;d.remainingSkills[h]||(d.remainingSkills[h]={total:0});d.remainingSkills[h][r]=0;d.remainingSkills[h].total-=v;d.remainingSkills[h][r]-=v;if(!p)continue}for(h=c[r].lvl-2;4>h++&&(!a[h]||(v=Math.min(p,a[h],-e[n][1]),a[h]-=v,e[n][1]+=v,d.decosUsed.push([r,1,`Slot lvl${h+1}`,v]),0!==e[n][1])););}return g})();return[d,a]};
function generateAugmentCombinations(a,e,c,g){a:for(let l=0;l<c.length;l++){const d=c[l];for(let n=l+1;n<c.length;n++){const h=c[n];for(let v=n+1;v<c.length;v++){const r=c[v];let k=3;const p=[];if(d+h+r>g)continue;let m={[d]:1};m[h]=(m[h]||0)+1;m[r]=(m[r]||0)+1;b:for(let w=0,u=Object.entries(m);w<u.length;++w){c:for(let [b,f]of Object.entries(a[u[w][0]]))if("total"!==b)if(e.has(b)){for(k+=f;f++&&k--;)p.push(b);if(0===f)break b}else if(1<f){if(0>=(k+=f))break b;if(0>=(u[w][1]+=f-1))break c}if(!(0<
k)&&(previousBestSolution=[p,d+h+r],d+h+r===g))break a}}}}return previousBestSolution}
const findBestSum3=(a,e)=>{for(let c=0,g=1,l=2,d=a.length;l<d;c++,g++,l++)if(!(a[c]+a[g]+a[l]<e))return a[c]+a[g]+a[l]===e||0===c||a[--c]+a[g]+a[l]<=e||a[c]+a[--g]+a[l]<=e?[a[c],a[g],a[l],a[c]+a[g]+a[l]]:[a[c],a[g],a[l-1],a[c]+a[g]+a[l-1]];return[a[a.length-3],a[a.length-2],a[a.length-1],a[a.length-3]+a[a.length-2]+a[a.length-1]]},findBestSum2=(a,e)=>{for(let c=0,g=1;g<a.length;c++,g++)if(!(a[c]+a[g]<e))return a[c]+a[g]===e||0===c||a[--c]+a[g]<=e?[a[c],a[g],a[c]+a[g]]:[a[c],a[g-1],a[c]+a[g-1]];return[a[a.length-
2],a[a.length-1],a[a.length-2]+a[a.length-1]]},findBestSum1=(a,e)=>{a=a.filter(c=>c<=e).pop();return[a,a]},getQuriousSkills=(a,e,c,g)=>{let {decosUsed:l,remainingSkills:d}=a,n=a=0;for(var h in d)n+=d[h].total;h=b=>{let f=0;0<b.fodderSkills.length&&(++f,++b.skillsRemovedCount);const q=5*(1+f);b.augs.push({[f?"-Skill":"-Def"]:[f?b.fodderSkills.pop():q]});l.push([f?b.fodderSkills.pop():q,f?"-Skill":"-Def",b.name,1]);b.quriousPoints+=q;b.unBloatedPoints=~~(b.quriousPoints/3)};const v=(b,f)=>{for(const q of b){b=
d[q];let A=Object.keys(b)[1];if(5===f.innateSkills.size)for(let B=1,x=Object.keys(b);B<x.length;B++){if(d[x[B]]){A=x[B];break}if(B===x.length-1)return}f.augs.push({"+Skill":A});l.push([A,1,f.name,1]);f.innateSkills.add(A);0===--b.total?delete d[q]:0===--b[A]&&delete d[q][A];--n}};for(var r=0;r<e.length;r++){var k=e[r];if(0>=n)continue;a=6-k.augs.length;if(n<a)for(;a>n;)h(k),--a;if(1>a)continue;var p=a,m=1;let b=0,f=0,q=Object.keys(d);for(;p--;)f+=+q[b],p&&++m>d[q[b]].total&&(m=1,++b);if(k.unBloatedPoints<
f&&(--a,h(k),k.unBloatedPoints<(f-=q[b])&&(--a,h(k),0===m-1&&--b,k.unBloatedPoints<f-q[b]))){--a;continue}p=[];for(var w in d)for(m=Math.min(d[w].total,a);m--;)p.push(+w);m=[];if(3===a)m=findBestSum3(p,k.unBloatedPoints);else if(2===a)m=findBestSum2(p,k.unBloatedPoints);else if(1===a&&k.unBloatedPoints>=p[0])m=findBestSum1(p,k.unBloatedPoints);else continue;if(0>(k.quriousPoints-=Number(3*m.pop()))){console.log(`${k.name} has ${k.quriousPoints} points}`,k);debugger}v(m,k)}w=(b,f)=>{b.augs.splice(f,
1);f=findBestSum1(Object.keys(d).filter(q=>q<=b.quriousPoints),~~(b.quriousPoints/3));b.quriousPoints-=3*f[1];v([f[0]],b)};if(0<n)for(const b of e)if(!(4<b.innateSkills.size&&Object.entries(d).filter(f=>Object.keys(f[1]).some(q=>b.innateSkills.has(q))))){if(!Object.keys(d).length)break;for(a=b.augs.length-1;--a;)b.augs.some(f=>f["-Def"])&&b.quriousPoints-5>=3*Object.keys(d)[0]?(b.quriousPoints-=5,w(b,a)):b.augs.some(f=>f["-Skill"])&&3*Object.keys(d)[0]<=b.quriousPoints-10&&(b.quriousPoints-=10,w(b,
a))}if(Object.keys(d).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};w=[0,0,0,0,0];let u={};for(let b of e){if(5>b.quriousPoints||!b.fodderCount)continue;const f=Math.min(b.fodderCount,~~(b.quriousPoints/5));Object.keys(b.skills).forEach(q=>{u[q]=u[q]?u[q]+(g[q]?Math.min(c[q].max-g[q],f):f):g[q]?Math.min(c[q].max-g[q],f):f});if(!(4<b.innateSkills.size||8>b.quriousPoints))for(a=b.augs.length,h=b.skillsRemovedCount,r=b.quriousPoints+0;0<=--a&&!((r-=0<=--h?5:10)<3*a);)for(k=~~(r/
a/3);k--;)++w[k]}return{quriousAugs:l,armorPieces:e,theseExtraPoints:w,newSkills:u,arr:!n}},combineDecos=(a,e)=>{const [...c]=e;a.forEach(g=>{c[0]+=g[0];c[1]+=g[1];c[2]+=g[2];c[3]+=g[3]});return c},max=(a,e)=>a>=e?a:e,getMostSkills=(a,e)=>{for(const c of a){for(a=0;4>a;a++)e.remainingSlots[a]=max(e.remainingSlots[a],c.remainingSlots[a]);for(a=0;5>a;a++)e.quriousSkills[a]=max(e.quriousSkills[a],c.quriousSkills[a]);for(const [g,l]of Object.entries(c.armorSkills))e.armorSkills[g]=max(e.armorSkills[g],
l)}};function sumArmorSkills(a,e){const c={};a.forEach(g=>{Object.entries(g.skills).forEach(([l,d])=>{e[l]&&(c[l]=(c[l]||0)+d)})});return c}
self.addEventListener("message",a=>{var e=[0,0];var c={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var g=[];let l=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const d of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[d[0]],a.data.armors.chest[d[1]],a.data.armors.arm[d[2]],a.data.armors.waist[d[3]],a.data.armors.leg[d[4]]];const n=testThisBatch(a.data);n&&(getMostSkills(n,c),e[1]+=n.length,++e[0],l&&g.push(n));l&&25===g.length&&(--l,postMessage([g,
!1,e]),e=[0,0])}postMessage([g,c,e])});
const testThisBatch=a=>{const {thisWeapon:e,theseCharms:c,requiredSkills:g,skillInfo:l,theseArmors:d,skills:n}=a,h=sumArmorSkills(d,n),v=combineDecos([e,d[0].decos,d[1].decos,d[2].decos,d[3].decos,d[4].decos],a.charmSlots);let r=[];c.forEach(k=>{if(!Object.entries(k).some(([t,z])=>h[t]&&h[t]+z>l[t].max)){var p=[],m=[],w=-v[0];for(let [t,z]of g){h[t]&&(z+=h[t]);k[t]&&(z+=k[t]);const {lvl:D,max:H}=l[t];if(z>H)return;1===D&&(w-=z);0>z&&m.push([t,z])}var u=[];for(var b=0;b<d.length;b++){var f={...d[b]};
f.augs=[...d[b].augs];f.fodderSkills=[...d[b].fodderSkills];f.skillsRemovedCount=Math.min(3,d[b].fodderCount);f.innateSkills=new Set(Object.keys(d[b].skills));u.push(f)}a:for(let t=0,z=u.length;t<z;t++){b=5-u[t].innateSkills.size;f=6-u[t].augs.length;if(b>=f)continue;let D=~~(u[t].quriousPoints/3);b=f-b;let H=~~(D/f);f=([y,C],F,E=-1)=>{if(!(l[y].qurious<H||l[y].qurious*F>D)){if(-1===E)for(let G=0;G<m.length;G++)if(m[G][0]===y){E=G;break}if(C<=-F&&D>=l[y].qurious*F){C=Math.min(-C,F);u[t].quriousPoints-=
l[y].qurious*C*3;u[t].unBloatedPoints=~~(u[t].quriousPoints/3);0<=(m[E][1]+=C)&&m.splice(E,1);u[t].innateSkills.add(y);for(p.push([y,1,u[t].name,C]);C--;)u[t].augs.push({"+Skill":y});return!0}}};for(let y of Object.entries(d[t].skills))if(h[y[0]]&&f(y,b))continue a;let I=m.length;for(;--I;)if(f(m[I],b+1,I))continue a}var [q,A]=getDecos(v.slice(0),m,l,p,w),{quriousAugs:B,armorPieces:x,theseExtraPoints:J,newSkills:K,arr:L}=getQuriousSkills(q,u,l,n);if(!L)return!1;if(x.some(t=>void 0==t.name)){debugger;
console.log(x)}r.push({usedSkills:[].concat(B,Object.entries(h),Object.entries(k)),armors:[[x[0].name,x[0]],[x[1].name,x[1]],[x[2].name,x[2]],[x[3].name,x[3]],[x[4]?.name,x[4]]],remainingSlots:A,quriousSkills:J,armorSkills:K,thisCharm:k,decoArr:v})}});r=r.filter(k=>{let p={};k.usedSkills.forEach(m=>{let w=m[3]?m[1]*m[3]:m[1];p[m[0]]=p[m[0]]?p[m[0]]+w:w});if(a.requiredSkills.every(m=>p[m[0]]+=0<=m[1]))return!0;console.log({set:k,ugh:p,skills:n});debugger});if(r[0])return r};

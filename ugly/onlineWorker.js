const getDecos=([...a],c,b,d,f)=>{const e={remainingSkills:{}};e.decosUsed=d;(()=>{for(let g=0;g<c.length&&0<a[3];g++){const h=b[c[g][0]].lvl4;if(0!==h&&c[g][1]<=-h&&(1!==b[c[g][0]].lvl||0<=(f-=h))){const l=~~Math.min(a[3],-c[g][1]/h);a[3]-=l;c[g][1]+=h*l;e.decosUsed.push([c[g][0],h,"Slot lvl4",l])}}})();((g=-1)=>{for(let [n,r]of c){++g;if(0<=r)continue;let t;switch(b[n].lvl){case 1:t=Math.min(-r,a[0]);break;case 2:t=Math.min(-r,a[1]+a[2]+a[3]);break;case 3:t=Math.min(-r,a[2]+a[3]);break;case 4:t=
Math.min(-r,a[3]);break;default:t=0}if(0>t+r){var h=b[n].qurious,l=t+r;e.remainingSkills[h]||(e.remainingSkills[h]={total:0});e.remainingSkills[h][n]=0;e.remainingSkills[h].total-=l;e.remainingSkills[h][n]-=l;if(!t)continue}for(h=b[n].lvl-2;4>h++&&(!a[h]||(l=Math.min(t,a[h],-c[g][1]),a[h]-=l,c[g][1]+=l,e.decosUsed.push([n,1,`Slot lvl${h+1}`,l]),0!==c[g][1])););}return d})();return[e,a]};
function generateAugmentCombinations(a,c,b,d){a:for(let f=0;f<b.length;f++){const e=b[f];for(let g=f+1;g<b.length;g++){const h=b[g];for(let l=g+1;l<b.length;l++){const n=b[l];let r=3;const t=[];if(e+h+n>d)continue;let p={[e]:1};p[h]=(p[h]||0)+1;p[n]=(p[n]||0)+1;b:for(let k=0,m=Object.entries(p);k<m.length;++k){c:for(let [q,v]of Object.entries(a[m[k][0]]))if("total"!==q)if(c.has(q)){for(r+=v;v++&&r--;)t.push(q);if(0===v)break b}else if(1<v){if(0>=(r+=v))break b;if(0>=(m[k][1]+=v-1))break c}if(!(0<
r)&&(previousBestSolution=[t,e+h+n],e+h+n===d))break a}}}}return previousBestSolution}
const findBestSum3=(a,c)=>{for(let b=0,d=1,f=2,e=a.length;f<e;b++,d++,f++)if(!(a[b]+a[d]+a[f]<c))return a[b]+a[d]+a[f]===c||0===b||a[--b]+a[d]+a[f]<=c||a[b]+a[--d]+a[f]<=c?[a[b],a[d],a[f],a[b]+a[d]+a[f]]:[a[b],a[d],a[f-1],a[b]+a[d]+a[f-1]];return[a[a.length-3],a[a.length-2],a[a.length-1],a[a.length-3]+a[a.length-2]+a[a.length-1]]},findBestSum2=(a,c)=>{for(let b=0,d=1;d<a.length;b++,d++)if(!(a[b]+a[d]<c))return a[b]+a[d]===c||0===b||a[--b]+a[d]<=c?[a[b],a[d],a[b]+a[d]]:[a[b],a[d-1],a[b]+a[d-1]];return[a[a.length-
2],a[a.length-1],a[a.length-2]+a[a.length-1]]},findBestSum1=(a,c)=>{a=a.filter(b=>b<=c).pop();return[a,a]},getPoints=(a,c)=>{let b=0;0<a.fodderSkills.length&&(++b,++a.skillsRemovedCount);const d=5*(1+b);a.augs.push({[b?"-Skill":"-Def"]:[b?a.fodderSkills.pop():d]});c.push([b?a.fodderSkills.pop():d,b?"-Skill":"-Def",a.name,1]);a.quriousPoints+=d;a.unBloatedPoints=~~(a.quriousPoints/3);return[a,c]},pushAugs=(a,c,b,d,f)=>{for(const e of a){if(void 0===e)continue;a=d[e];let g=Object.keys(a)[1];if(5===
c.innateSkills.size)for(let h=1,l=Object.keys(a);h<l.length;h++){if(d[l[h]]){g=l[h];break}if(h===l.length-1)return}c.augs.push({"+Skill":g});f.push([g,1,c.name,1]);c.innateSkills.add(g);0===--a.total?delete d[e]:0===--a[g]&&delete d[e][g];--b}return b},minimumCostPerAugmentCount=(a,c)=>{c=Object.entries(c);let b=0;for(let d=0;a&&d<c.length;++d){let f=Math.min(c[d][1].total,a);b+=f*+c[d][0];a-=f}return b},getQuriousSkills=(a,c,b,d)=>{let {decosUsed:f,remainingSkills:e}=a;a=0;let g=Object.values(e).reduce((k,
m)=>k+m.total,0);for(var h=0;h<c.length;h++){var l=c[h];if(!(0>=g)){a=6-l.augs.length;var n=g<a?a-g:0;for(a-=n;0<a&&minimumCostPerAugmentCount(a,e)>l.unBloatedPoints;)++n,--a;for(;n--;)[l,f]=getPoints(l,f);if(!(1>a)){n=[];for(var r in e)for(var t=Math.min(e[r].total,a);t--;)n.push(+r);t=[];if(3===a)t=findBestSum3(n,l.unBloatedPoints);else if(2===a)t=findBestSum2(n,l.unBloatedPoints);else if(1===a&&l.unBloatedPoints>=n[0])t=findBestSum1(n,l.unBloatedPoints);else continue;if(0>(l.quriousPoints-=Number(3*
t.pop()))||void 0===l.quriousPoints){console.log(`${l.name} has ${l.quriousPoints} points}`,l);debugger}g=pushAugs(t,l,g,e,f)}}}r=(k,m)=>{k.augs.splice(m,1);m=findBestSum1(Object.keys(e).filter(q=>q<=k.quriousPoints),~~(k.quriousPoints/3));k.quriousPoints-=3*m[1];g=pushAugs([m[0]],k,g,e,f)};if(0<g)for(const k of c)if(!(4<k.innateSkills.size)||Object.entries(e).filter(m=>Object.keys(m[1]).some(q=>k.innateSkills.has(q)))){if(!Object.keys(e).length)break;for(a=k.augs.length-1;--a;)k.augs.some(m=>m["-Def"])&&
k.quriousPoints-5>=3*+Object.keys(e)[0]?(k.quriousPoints-=5,r(k,a)):k.augs.some(m=>m["-Skill"])&&3*+Object.keys(e)[0]<=k.quriousPoints-10&&(k.quriousPoints-=10,r(k,a))}if(Object.keys(e).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};r=[0,0,0,0,0];let p={};for(let k of c){if(5>k.quriousPoints||!k.fodderCount)continue;const m=Math.min(k.fodderCount,~~(k.quriousPoints/5));Object.keys(k.skills).forEach(q=>{p[q]=p[q]?p[q]+(d[q]?Math.min(b[q].max-d[q],m):m):d[q]?Math.min(b[q].max-
d[q],m):m});if(!(4<k.innateSkills.size||8>k.quriousPoints))for(a=k.augs.length,h=3-k.skillsRemovedCount,l=k.quriousPoints+0;0<=--a&&!((l-=0<=--h?5:10)<3*a);)for(n=~~(l/a/3);n--;)++r[n]}return{quriousAugs:f,armorPieces:c,theseExtraPoints:r,newSkills:p,arr:!g}},combineDecos=(a,c)=>{const [...b]=c;a.forEach(d=>{b[0]+=d[0];b[1]+=d[1];b[2]+=d[2];b[3]+=d[3]});return b},max=(a,c)=>a>=c?a:c,getMostSkills=(a,c)=>{for(const b of a){for(a=0;4>a;a++)c.remainingSlots[a]=max(c.remainingSlots[a],b.remainingSlots[a]);
for(a=0;5>a;a++)c.quriousSkills[a]=max(c.quriousSkills[a],b.quriousSkills[a]);for(const [d,f]of Object.entries(b.armorSkills))c.armorSkills[d]=max(c.armorSkills[d],f)}};function sumArmorSkills(a,c){const b={};a.forEach(d=>{Object.entries(d.skills).forEach(([f,e])=>{c[f]&&(b[f]=(b[f]||0)+e)})});return b}
self.addEventListener("message",a=>{var c=[0,0];var b={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var d=[];let f=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const e of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[e[0]],a.data.armors.chest[e[1]],a.data.armors.arm[e[2]],a.data.armors.waist[e[3]],a.data.armors.leg[e[4]]];const g=testThisBatch(a.data);g&&(getMostSkills(g,b),c[1]+=g.length,++c[0],f&&d.push(g));f&&25===d.length&&(--f,postMessage([d,
!1,c]),c=[0,0])}postMessage([d,b,c])});
const testThisBatch=a=>{const {thisWeapon:c,theseCharms:b,requiredSkills:d,skillInfo:f,theseArmors:e,skills:g}=a,h=sumArmorSkills(e,g),l=combineDecos([c,e[0].decos,e[1].decos,e[2].decos,e[3].decos,e[4].decos],a.charmSlots);let n=[];b.forEach(r=>{if(!Object.entries(r).some(([u,y])=>h[u]&&h[u]+y>f[u].max)){var t=[],p=[],k=-l[0];for(let [u,y]of d){h[u]&&(y+=h[u]);r[u]&&(y+=r[u]);const {lvl:A,max:E}=f[u];if(y>E)return;1===A&&(k-=y);0>y&&p.push([u,y])}var m=[];for(var q=0;q<e.length;q++){var v={...e[q]};
v.augs=[...e[q].augs];v.fodderSkills=[...e[q].fodderSkills];v.skillsRemovedCount=Math.min(3,e[q].fodderCount);v.innateSkills=new Set(Object.keys(e[q].skills));m.push(v)}a:for(let u=0,y=m.length;u<y;u++){q=5-m[u].innateSkills.size;v=6-m[u].augs.length;if(q>=v)continue;let A=~~(m[u].quriousPoints/3);q=v-q;let E=~~(A/v);v=([x,z],C,B=-1)=>{if(!(f[x].qurious<E||f[x].qurious*C>A)){if(-1===B)for(let D=0;D<p.length;D++)if(p[D][0]===x){B=D;break}if(z<=-C&&A>=f[x].qurious*C){z=Math.min(-z,C);m[u].quriousPoints-=
f[x].qurious*z*3;m[u].unBloatedPoints=~~(m[u].quriousPoints/3);0<=(p[B][1]+=z)&&p.splice(B,1);m[u].innateSkills.add(x);for(t.push([x,1,m[u].name,z]);z--;)m[u].augs.push({"+Skill":x});return!0}}};for(let x of m[u].innateSkills.entries())if(h[x]&&v(x,q))continue a;let F=p.length;for(;--F;)if(v(p[F],q+1,F))continue a}var [G,H]=getDecos(l.slice(0),p,f,t,k),{quriousAugs:I,armorPieces:w,theseExtraPoints:J,newSkills:K,arr:L}=getQuriousSkills(G,m,f,g);if(!L)return!1;if(w.some(u=>void 0==u.name)){debugger;
console.log(w)}n.push({usedSkills:[].concat(I,Object.entries(h),Object.entries(r)),armors:[[w[0].name,w[0]],[w[1].name,w[1]],[w[2].name,w[2]],[w[3].name,w[3]],[w[4]?.name,w[4]]],remainingSlots:H,quriousSkills:J,armorSkills:K,thisCharm:r,decoArr:l})}});n=n.filter(r=>{let t={};r.usedSkills.forEach(p=>{let k=p[3]?p[1]*p[3]:p[1];t[p[0]]=t[p[0]]?t[p[0]]+k:k});if(a.requiredSkills.every(p=>t[p[0]]+=0<=p[1]))return!0;console.log({set:r,ugh:t,skills:g});debugger});if(n[0])return n};

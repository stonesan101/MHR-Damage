const getDecos=([...a],c,d,b,k)=>{const e={remainingSkills:{}};e.decosUsed=b;for(b=0;b<c.length&&0<a[3];b++){var g=d[c[b][0]].lvl4;if(0!==g&&c[b][1]<=-g&&(1!==d[c[b][0]].lvl||0<=(k-=g))){var h=~~Math.min(a[3],-c[b][1]/g);a[3]-=h;c[b][1]+=g*h;e.decosUsed.push([c[b][0],g,"Slot lvl4",h])}}k=-1;for(let [f,l]of c)if(++k,!(0<=l)){switch(d[f].lvl){case 1:b=Math.min(-l,a[0]);break;case 2:b=Math.min(-l,a[1]+a[2]+a[3]);break;case 3:b=Math.min(-l,a[2]+a[3]);break;case 4:b=Math.min(-l,a[3]);break;default:b=0}if(0>
b+l&&(g=d[f].qurious,h=b+l,e.remainingSkills[g]||(e.remainingSkills[g]={total:0}),e.remainingSkills[g][f]=0,e.remainingSkills[g].total-=h,e.remainingSkills[g][f]-=h,!b))continue;for(g=d[f].lvl-2;4>g++&&(!a[g]||(h=Math.min(b,a[g],-c[k][1]),a[g]-=h,c[k][1]+=h,e.decosUsed.push([f,1,`Slot lvl${g+1}`,h]),0!==c[k][1])););}return[e,a]};
function addSkills(a,c,d,b,k,e){a:for(let [g,h]of Object.entries(b)){for(let f of a.values())if(c[g][f]){b=Math.min(h,c[g][f]);d[0]+=+g*b;e-=b;for(h-=b;b--;)d.push([f,g]);if(!e)break a;if(!h)continue a}for(let [f,l]of Object.entries(c[g]))if(!(2>l)){if(0>--k)break a;b=Math.min(h,l);d[0]+=+g*b;e-=b;for(h-=b;b--;)d.push([f,g]);if(!e)break a;if(!h)continue a}}return d}
function SkillRestrictedCombinations3(a,c,d,b){let k=[0];a=Object.fromEntries(Object.entries(a).map(([e,g])=>[e,Object.fromEntries(Object.entries(g).filter(([h])=>"total"!==h).sort(([,h],[,f])=>f-h))]));for(let e=0;e<d.length;e++){const g=d[e];for(let h=e+1;h<d.length;h++){const f=d[h];for(let l=h+1;l<d.length;l++){const m=d[l];if(g+f+m>b)break;let p=5-c.size,q=[0],u={[g]:1};u[f]=(u[f]||0)+1;u[m]=(u[m]||0)+1;q=addSkills(c,a,q,u,p,3);q[0]<=b&&q[0]>k[0]&&([...k]=q)}}}return k}
function SkillRestrictedCombinations2(a,c,d,b){let k=[0];a=Object.fromEntries(Object.entries(a).map(([e,g])=>[e,Object.fromEntries(Object.entries(g).filter(([h])=>"total"!==h).sort(([,h],[,f])=>f-h))]));for(let e=0;e<d.length;e++){const g=d[e];for(let h=e+1;h<d.length;h++){const f=d[h];if(g+f>b)break;let l=5-c.size,m=[0],p={[g]:1};p[f]=(p[f]||0)+1;m=addSkills(c,a,m,p,l,2);m[0]<=b&&m[0]>k[0]&&([...k]=m)}}return k}
const findBestSum3=(a,c)=>{for(let d=0,b=1,k=2,e=a.length;k<e;d++,b++,k++)if(!(a[d]+a[b]+a[k]<c))return a[d]+a[b]+a[k]===c||0===d||a[--d]+a[b]+a[k]<=c||a[d]+a[--b]+a[k]<=c?[a[d],a[b],a[k],a[d]+a[b]+a[k]]:[a[d],a[b],a[k-1],a[d]+a[b]+a[k-1]];c=a.length;return[a[c-3],a[c-2],a[c-1],a[c-3]+a[c-2]+a[c-1]]},findBestSum2=(a,c)=>{for(let d=0,b=1;b<a.length;d++,b++)if(!(a[d]+a[b]<c))return a[d]+a[b]===c||0===d||a[--d]+a[b]<=c?[a[d],a[b],a[d]+a[b]]:a.slice(-2).concat(a.slice(-2).reduce((k,e)=>k+e)[0]);c=a.length;
return[a[c-2],a[c-1],a[c-2]+a[c-1]]},findBestSum1=(a,c)=>{a=a.filter(d=>d<=c).pop();return[a,a]},getPoints=(a,c)=>{let d=0;0<a.fodderSkills.length&&(++d,++a.skillsRemovedCount);const b=5*(1+d);a.augs.push({[d?"-Skill":"-Def"]:[d?a.fodderSkills.pop():b]});c.push([d?a.fodderSkills.pop():b,d?"-Skill":"-Def",a.name,1]);a.quriousPoints+=b;a.unBloatedPoints=~~(a.quriousPoints/3);return[a,c]},pushAugs=(a,c,d,b,k)=>{for(const e of a){let [g,h]=Array.isArray(e)?e:[Object.keys(b[e])[1],e];c.augs.push({"+Skill":g});
k.push([g,1,c.name,1]);c.innateSkills.add(g);0===--b[h].total?delete b[h]:0===--b[h][g]&&delete b[h][g];--d}return d},minimumCostForPossibleAugs=(a,c)=>{let d=0;for(let b=0;a&&b<c.length;++b){let k=Math.min(c[b][1].total,a);d+=k*+c[b][0];a-=k}return d},getQuriousSkills=(a,c,d,b)=>{let {decosUsed:k,remainingSkills:e}=a,g=Object.values(e).reduce((n,t)=>n+t.total,0);a=[];for(var h=0;h<c.length;h++){var f={...c[h]};f.augs=[...c[h].augs];f.fodderSkills=[...c[h].fodderSkills];f.skillsRemovedCount=Math.min(3,
c[h].fodderCount);f.innateSkills=new Set(Object.keys(c[h].skills));a.push(f);var l=Object.entries(e);if(g&&l.length){for(var m=Math.min(6-f.augs.length,g),p=g<6-f.augs.length?6-f.augs.length-g:0;m&&minimumCostForPossibleAugs(m,l)>f.unBloatedPoints;)++p,--m;if(m){for(;p--;)[f,k]=getPoints(f,k);l=[];for(var q in e)for(p=Math.min(e[q].total,m);p--;)l.push(+q);p=[];if(5-f.innateSkills.size>=l.length){if(3===m)p=findBestSum3(l,f.unBloatedPoints);else if(2===m)p=findBestSum2(l,f.unBloatedPoints);else if(1===
m&&f.unBloatedPoints>=l[0])p=findBestSum1(l,f.unBloatedPoints);else continue;if(0>(f.quriousPoints-=Number(3*p.pop()))||void 0===f.quriousPoints){console.log(`${f.name} has ${f.quriousPoints} points}`,f);debugger}}else if(3===m?p=SkillRestrictedCombinations3(e,f.innateSkills,l,f.unBloatedPoints):2===m&&(p=SkillRestrictedCombinations2(e,f.innateSkills,l,f.unBloatedPoints)),0>(f.quriousPoints-=Number(3*p.shift()))||void 0===f.quriousPoints){console.log(`${f.name} has ${f.quriousPoints} points}`,f);
debugger}g=pushAugs(p,f,g,e,k)}}}c=(n,t)=>{n.augs.splice(t,1);t=findBestSum1(Object.keys(e).filter(r=>+r<=~~(n.quriousPoints/3)));t[0]&&(n.quriousPoints-=3*t[1],g=pushAugs([t[0]],n,g,e,k))};if(0<g)for(const n of a)if(!(4<n.innateSkills.size&&Object.entries(e).filter(t=>Object.keys(t[1]).every(r=>!n.innateSkills.has(r))))){if(!Object.keys(e).length)break;for(q=n.augs.length-1;--q;)n.augs.some(t=>t["-Def"])&&n.quriousPoints-5>=3*+Object.keys(e)[0]?(n.quriousPoints-=5,c(n,q)):n.augs.some(t=>t["-Skill"])&&
n.quriousPoints-10>=3*+Object.keys(e)[0]&&(n.quriousPoints-=10,c(n,q))}if(Object.keys(e).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};c=[0,0,0,0,0];let u={};for(let n of a){if(5>n.quriousPoints||!n.fodderCount)continue;const t=Math.min(n.fodderCount,~~(n.quriousPoints/5));Object.keys(n.skills).forEach(r=>{u[r]=u[r]?u[r]+(b[r]?Math.min(d[r].max-b[r],t):t):b[r]?Math.min(d[r].max-b[r],t):t});if(!(4<n.innateSkills.size||8>n.quriousPoints))for(q=n.augs.length,h=3-n.skillsRemovedCount,
f=n.quriousPoints+0;0<=--q&&!((f-=0<=--h?5:10)<3*q);)for(m=~~(f/q/3);m--;)++c[m]}return{quriousAugs:k,armorPieces:a,theseExtraPoints:c,newSkills:u,arr:!g}},combineDecos=(a,c)=>{const [...d]=c;a.forEach(b=>{d[0]+=b[0];d[1]+=b[1];d[2]+=b[2];d[3]+=b[3]});return d},max=(a,c)=>a>=c?a:c,getMostSkills=(a,c)=>{for(const d of a){for(a=0;4>a;a++)c.remainingSlots[a]=max(c.remainingSlots[a],d.remainingSlots[a]);for(a=0;5>a;a++)c.quriousSkills[a]=max(c.quriousSkills[a],d.quriousSkills[a]);for(const [b,k]of Object.entries(d.armorSkills))c.armorSkills[b]=
max(c.armorSkills[b],k)}};
self.addEventListener("message",a=>{var c=[0,0];var d={quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]};var b=[];let k=1;a.data.requiredSkills=Object.entries(a.data.skills);for(const e of Object.values(a.data.permutations)){a.data.theseArmors=[a.data.armors.helm[e[0]],a.data.armors.chest[e[1]],a.data.armors.arm[e[2]],a.data.armors.waist[e[3]],a.data.armors.leg[e[4]]];const g=testThisBatch(a.data);g&&(getMostSkills(g,d),c[1]+=g.length,++c[0],k&&b.push(g));k&&25===b.length&&(--k,postMessage([b,
!1,c]),b.length=0,c=[0,0])}postMessage([b,d,c])});
const testThisBatch=a=>{const {thisWeapon:c,theseCharms:d,requiredSkills:b,skillInfo:k,theseArmors:e,skills:g}=a,h={};for(let m of e)for(let [p,q]of Object.entries(m.skills))g[p]&&(h[p]=(h[p]||0)+q);const f=combineDecos([c,e[0].decos,e[1].decos,e[2].decos,e[3].decos,e[4].decos],a.charmSlots);let l=[];d.forEach(m=>{if(!Object.entries(m).every(([v,w])=>!h[v]||h[v]+w<=k[v].max)){var p=[],q=-f[0];for(let [v,w]of b){h[v]&&(w+=h[v]);m[v]&&(w+=m[v]);const {lvl:x,max:y}=k[v];if(w>y)return;1===x&&(q-=w);0>
w&&p.push([v,w])}var [u,n]=getDecos(f.slice(0),p,k,[],q),{quriousAugs:t,armorPieces:r,theseExtraPoints:z,newSkills:A,arr:B}=getQuriousSkills(u,e,k,g);if(!B)return!1;if(r.some(v=>void 0==v.name)){debugger;console.log(r)}l.push({usedSkills:[].concat(t,Object.entries(h),Object.entries(m)),armors:[[r[0].name,r[0]],[r[1].name,r[1]],[r[2].name,r[2]],[r[3].name,r[3]],[r[4]?.name,r[4]]],remainingSlots:n,quriousSkills:z,armorSkills:A,thisCharm:m,decoArr:f})}});l=l.filter(m=>{let p={};m.usedSkills.forEach(q=>
{let u=q[3]?q[1]*q[3]:q[1];p[q[0]]=p[q[0]]?p[q[0]]+u:u});if(a.requiredSkills.every(q=>p[q[0]]+=0<=q[1]))return!0;console.log({set:m,ugh:p,skills:g});debugger});if(l[0])return l};

const getDecos=([...e],t,s,l,i)=>{const n={remainingSkills:{},decosUsed:[]};return(()=>{for(let l=0;l<t.length;l++){if(!e[3])return;const o=s[t[l][0]].lvl4;if(0!==o&&t[l][1]<=-1*o&&(1!==s[t[l][0]].lvl||(i-=o)>=0)){const s=~~Math.min(e[3],-1*t[l][1]/o);e[3]-=s,t[l][1]+=o*s,n.decosUsed.push([t[l][0],o,"Slot lvl4",s])}}})(),n.check=(()=>{for(const[i,o]of t){if(!o||20===s[i].querious)continue;let t=0;switch(s[i].lvl){case 1:t=Math.min(-1*o,e[0]);break;case 2:t=Math.min(-1*o,e[1]+e[2]+e[3]);break;case 3:t=Math.min(-1*o,e[2]+e[3]);break;default:t=Math.min(-1*o,e[3])}if(t+o<0){const e=s[i].qurious;let r=t+o;if(n.remainingSkills[e]||(n.remainingSkills[e]={total:0}),e>=3&&(l+=r)<0||e<3&&(l+=r/1.25)<0)return!1;for(n.remainingSkills[e][i]=0;r++;)++n.remainingSkills[e].total,++n.remainingSkills[e][i];if(!t)continue}let r=s[i].lvl-2;for(;r++<4;){if(!e[r])continue;const s=Math.min(t,e[r]);if(e[r]-=s,n.decosUsed.push([i,1,`Slot lvl${r+1}`,s]),o+s===0)break}}return l})(),[n,e]};function generateAugmentCombinations(e,t,s,l){let i=[];e:for(let n=0;n<s.length;n++){const o=s[n];for(let r=n+1;r<s.length;r++){const n=s[r];for(let u=r+1;u<s.length;u++){const r=s[u];let a=3-(5-t.size);if(o+n+r>l)break e;let f={a:1};f[n]?++f[n]:f[n]=1,f[r]?++f[r]:f[r]=1;t:for(let s=0,l=Object.entries(f).length;s<l.length&&l>0;++s)s:for(const[i,n]of Object.entries(e[l[s][0]]))if("total"!==i)if(t.has(i)){if((a+=n)<=0)break t;if((l[s][1]+=n)<=0)break s}else if(n>1){if((a+=n)<=0)break t;if((l[s][1]+=n-1)<=0)break s}if(!(a>0)&&(o+n+r<l&&(i=[o,n,r]),o+n+r>l))break e}}}return[i,i.reduce(((e,t)=>e+t))]}const findBestSum3=(e,t,s,l)=>{for(let s=0,l=1,i=2,n=e.length;i<n;s++,l++,i++)if(!(e[s]+e[l]+e[i]<t))return e[s]+e[l]+e[i]===t||0===s||e[--s]+e[l]+e[i]<=t||e[s]+e[--l]+e[i]<=t?[e[s],e[l],e[i],e[s]+e[l]+e[i]]:[e[s],e[l],e[i-1],e[s]+e[l]+e[i-1]];return[e[e.length-3],e[e.length-2],e[e.length-1],e[e.length-3]+e[e.length-2]+e[e.length-1]]},findBestSum2=(e,t)=>{for(let s=0,l=1;l<e.length;s++,l++)if(!(e[s]+e[l]<t))return e[s]+e[l]===t||0===s||e[--s]+e[l]<=t?[e[s],e[l],e[s]+e[l]]:[e[s],e[l-1],e[s]+e[l-1]];return[e[e.length-2],e[e.length-1],e[e.length-2]+e[e.length-1]]},findBestSum1=(e,t)=>{let s=e.filter((e=>e<=t)).pop();return[s,s]},getQuriousSkills=(e,t,s,l,i)=>{l+=5;let n=0;const o=[];let r=0;for(let t of Object.values(e))r+=t.total?t.total:0;const u=e=>{let t=0;e.fodderSkills.length>0&&(++t,++e.skillsRemovedCount);const l=5*(1+t);e.augs.push({[t?"-Skill":"-Def"]:[t?e.fodderSkills.pop():l]}),s.push([t?e.fodderSkills.pop():l,t?"-Skill":"-Def",e.name,1]),e.quriousPoints+=l,e.unbloatedPoints=~~(e.quriousPoints/3)},a=(t,l)=>{for(const i of t){if(l.innateSkills.size>4&&!Object.keys(e[i]).some((e=>l.innateSkills.has(e))))return;let t=e[i];const n=Object.keys(t)[1];l.augs.push({"+Skill":n}),s.push([n,1,l.name,1]),l.innateSkills.add(n),0==--t.total?delete e[i]:0==--t[n]&&delete t[n],--r}};for(let s=0;s<t.length;s++){let i={};if(i={...t[s]},i.augs=[...t[s].augs],i.fodderSkills=[...t[s].fodderSkills],i.skillsRemovedCount=Math.min(3,t[s].fodderCount),i.innateSkills=new Set(Object.keys(t[s].skills)),r<=0){o.push(i);continue}if(n=6-i.augs.length,r<n)for(;n>r;)u(i),--n;if(n<1){o.push(i);continue}let f=n,c=0,h=0,k=0,g=Object.keys(e);for(;f--;)k+=+g[h],f&&++c>=e[g[h]].total&&(c=0,++h);if(i.unbloatedPoints<k){if(--l<0)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};if(--n,u(i),i.unbloatedPoints<(k-=g[h])){if(--l<0)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};if(--n,u(i),c||--h,i.unbloatedPoints<k-g[h]){if(--l<0)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};--n,o.push(i);continue}}}const m=[];for(let t in e){const s=e[t].total;let l=Math.min(s,n);for(;l--;)m.push(+t)}let d=[];if(3===n)d=findBestSum3(m,i.unbloatedPoints);else if(2===n)d=findBestSum2(m,i.unbloatedPoints);else{if(!(1===n&&i.unbloatedPoints>=m[0])){if(--l<0)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};o.push(i);continue}d=findBestSum1(m,i.unbloatedPoints)}(i.quriousPoints-=Number(3*d.pop()))<0&&console.log(`${i.name} has ${i.quriousPoints} points}`,i),a(d,i),o.push(i)}const f=(t,s)=>{t.augs.splice(s,1);const l=findBestSum1(Object.keys(e).filter((e=>e<=t.quriousPoints)),~~(t.quriousPoints/3));t.quriousPoints-=3*l[1],a([l[0]],t)};if(r>0)for(const t of o){if(t.innateSkills.length>4)continue;if(!Object.keys(e).length)break;let s=t.augs.length-1;for(;--s;)t.augs[s]["-Def"]&&t.quriousPoints-5>=3*Object.keys(e)[0]?(t.quriousPoints-=5,f(t,s)):t.augs[s]["-Skill"]&&3*Object.keys(e)[0]<=t.quriousPoints-10&&(t.quriousPoints-=10,f(t,s))}if(Object.keys(e).length)return{quriousAugs:0,finalSkillCheck:0,returnArmors:0,arr:!1};let c=[0,0,0,0,0],h={};for(let e of o){if(e.quriousPoints<5||!e.fodderCount)continue;const t=Math.min(e.fodderCount,~~(e.quriousPoints/5));for(let s in Object.entries(e.skills))h[s]||i[s]?h[s]+=t:h[s]=t;if(e.innateSkills>4||e.quriousPoints<8)continue;let s=e.augs.length,l=e.skillsRemovedCount,n=e.quriousPoints+0;for(;--s>=0&&!((n-=--l>=0?5:10)<3*s);){let e=~~(n/s/3);for(;e--;)++c[e]}}return{quriousAugs:s,returnArmors:o,theseExtraPoints:c,newSkills:h,arr:!r}},combineDecos=(e,t)=>{const[...s]=t;return e.forEach((e=>{s[0]+=e[0],s[1]+=e[1],s[2]+=e[2],s[3]+=e[3]})),s},max=(e,t)=>e>=t?e:t,getMostSkills=(e,t)=>{for(const s of e){for(let e=0;e<4;e++)t.remainingSlots[e]=max(t.remainingSlots[e],s.remainingSlots[e]);for(let e=0;e<5;e++)t.quriousSkills[e]=max(t.quriousSkills[e],s.quriousSkills[e]);for(const[e,l]of Object.entries(s.armorSkills))t.armorSkills[e]=max(t.armorSkills[e],l)}};function sumArmorSkills(e,t){const s={};return e.forEach((e=>{Object.entries(e.skills).forEach((([e,l])=>{t[e]&&(s[e]=(s[e]||0)+l)}))})),s}addEventListener("message",(e=>{let t={count:[0,0],stats:{quriousSkills:[0,0,0,0,0],armorSkills:{},remainingSlots:[0,0,0,0]},sets:[]},s=1;e.data.requiredSkills=Object.entries(e.data.skills);for(const l of Object.values(e.data.permutations)){e.data.theseArmors=[e.data.armors.helm[l[0]],e.data.armors.chest[l[1]],e.data.armors.arm[l[2]],e.data.armors.waist[l[3]],e.data.armors.leg[l[4]]];const i=testThisBatch(e.data);i&&(getMostSkills(i,t.stats),t.count[1]+=i.length,++t.count[0],s&&t.sets.push(i)),s&&25===t.sets.length&&(--s,postMessage([t.sets,!1,t.count]),t.count=[0,0])}postMessage([t.sets,t.stats,t.count])}));const testThisBatch=e=>{const{thisWeapon:t,theseCharms:s,requiredSkills:l,skillInfo:i,theseArmors:n,skills:o}=e,r=sumArmorSkills(n,o),u=combineDecos([t,n[0].decos,n[1].decos,n[2].decos,n[3].decos,n[4].decos],e.charmSlots);n.sort(((e,t)=>6-e.augs.length-5-(e.skills?.length?Object.keys(e.skills).length:0)-(6-t.augs.length-5-(t.skills?.length?Object.keys(t.skills).length:0))));let a=30;n.forEach((e=>a-=e.augs.length));let f=[];if(s.forEach((e=>{if(Object.entries(e).some((([e,t])=>r[e]&&r[e]+t>i[e].max)))return;const t=[];let s=-u[0];for(let[n,o]of l){r[n]&&(o+=r[n]),e[n]&&(o+=e[n]);const{lvl:l}=i[n];1===l&&(s-=o),o<0&&t.push([n,o])}n.forEach((e=>{let s=5-Object.keys(e.skills).length,l=6-e.augs.length;if(s>=l)return;let n=l-s+1,o=~~(~~(e.quriousPoints/3)/l);if(o>=4){let s=o>=5?0:t.length;for(;o>=5?s++<t.length:s-- >0;){let[l,o]=t[s],r=0;if(i[l].qurious>=3&&!i[l].lvl4){o<=-n&&e.quriousPoints>=i[l].qurious*n*3?(r=n,e.quriousPoints-=3*i[l].qurious):e.skills[l]&&(r=Math.min(-o,n),e.quriousPoints-=i[l].qurious*r*3);for(let e=0;e<t.length;e++)if(t[e][0]===l){0===(t[e][1]+=r)&&t.splice(e,1);break}for(e.skills[l]=r;r--;)e.augs.push({"+Skill":l});return}}}}));const[o,c]=getDecos(u.slice(0),t,i,a,s);if(!o.check)return!1;const{quriousAugs:h,returnArmors:k,theseExtraPoints:g,newSkills:m,arr:d}=getQuriousSkills(o.remainingSkills,n,o.decosUsed,o.check+1,i);if(!d)return!1;k.some((e=>null==e.name))&&console.log(k),f.push({usedSkills:[].concat(h,Object.entries(r),Object.entries(e)),armors:[[k[0].name,k[0]],[k[1].name,k[1]],[k[2].name,k[2]],[k[3].name,k[3]],[k[4]?.name,k[4]]],remainingSlots:c,quriousSkills:g,armorSkills:m,thisCharm:e})})),f=f.filter((t=>{let s={};if(t.usedSkills.forEach((e=>{let t=e[3]?e[1]*e[3]:e[1];s[e[0]]?s[e[0]]+=t:s[e[0]]=t})),e.requiredSkills.every((e=>s[e[0]]+=e[1]>=0)))return!0;console.log({set:t,ugh:s,skills:o})})),f[0]){const e=["helm","chest","arm","waist","leg"];return[...f]=f.map((t=>(t.armors.sort(((t,s)=>e.indexOf(t[1]?.type)-e.indexOf(s[1]?.type))),t))),f}return!1};

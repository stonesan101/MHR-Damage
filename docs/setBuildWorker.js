(()=>{var t={};let e,s;t.d=(e,s)=>{for(var o in s)t.o(s,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:s[o]})},t.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);class o{constructor(t){this.arrs=t.reverse(),this.len=t.length,this.names=new Map,this.charms=[],this.previousObj={total:0},this.previousCost=0,this.round2=[],this.round2Pointer=0,this.starting={};let e=this.len;for(this.costs=[{total:0,keys:new Int8Array(5),pointer:0},{total:1,skills:[],pointer:0},{total:2,skills:[],pointer:0},{total:1,skills:[],pointer:0},{total:1,skills:[],pointer:0},{total:3,skills:[],pointer:0}],this.costKeys=this.costs[0];e--;){let t=this.arrs[e];this.names.set(t[1],t),this.starting[t[1]]=t[3];let s=t.pop();s&&(s[0]=t,this.charms.push(s))}}useDecorationSlots(t,e){let s,o,i,n=0,r=0,l=0;this.round2Pointer=0;let u=0,a=0,f=this.len,c=this.arrs;t:for(;f--;)if(s=c[f],!((s[0]=s[3])<=0)){if(i=s[4],u=Math.min(i.length,4),!s[6]&&t[3]&&u)a=0;else{if(!(u>2&&t[i[2]])){this.round2[this.round2Pointer++]=s;continue t}a=2}for(o=s[1];a<u;){if(r=i[a++],l=i[a++],s[0]<l)continue;let u=Math.min(~~(s[0]/l),t[r]);if(u>0&&(e[n++]=o,e[n++]=l,e[n++]=r,e[n++]=u,t[r]-=u,0==(s[0]-=u*l)))continue t}this.round2[this.round2Pointer++]=s}return n}useDecosRound2(t,s,o,i){this.costKeys.pointer=0;let n=0;this.previousCost=0;let r,l,u=e.offsetTable,a=s.pointer,f=s.arr,c=this.round2,h=0,d=0,m=0,g=0,k=0;const p=this.costKeys.keys;let P=0,y=0,S=-1;t:for(;++S<this.round2Pointer;){for(r=c[S],l=r[4],h=l.length,d=!h||t[3]?0:h<4||t[l[2]]?2:h<6||t[l[4]]?4:h;d<h;)if(m=l[d++],g=l[d++],t[m]&&(k=Math.max(1,Math.min(~~(r[0]/g),t[m])),f[a++]=r[1],f[a++]=g,f[a++]=m,f[a++]=k,t[m]-=k,(r[0]-=k*g)<=0))continue t;if((n+=r[0])>i||(o-=r[0]*r[2])<u[n]||!r[2])return!0;this.previousCost===r[2]?(this.previousObj.total+=r[0],this.previousObj.skills[this.previousObj.pointer++]=r):(this.previousCost=r[2],p[P++]=this.previousCost,this.previousObj=this.costs[this.previousCost],this.previousObj.pointer=1,this.previousObj.total=r[0],this.previousObj.skills[0]=r)}if(P>1){this.costKeys.pointer=P;let t=-1;for(;++t<--P;)y=p[P],p[P]=p[t],p[t]=y}this.costKeys.total=n,s.pointer=a}}class i{constructor(t,e){this.armors=t,this.augmentRemovalOrder=[0,1,2,3,4],this.indexes=["helm","chest","arm","waist","leg"].map((t=>({index:-1,len:this.armors[t].length,type:t}))),this.decoSlotsResetValues=new Int8Array(4);for(let t=0;t<4;t++)this.decoSlotsResetValues[t]=e[t];this.budget=4,this.indexByType={helm:0,chest:1,arm:2,waist:3,leg:4},this.defAug={"-Def":5},this.theseArmors=[],this.offsetTable=new Int8Array([0,0,0,0,0,0,0,0,0,0,1,3,4,6,7,9,11,13,15,18])}setNextArmor(t,e,o){let i=0,n=this.armors[t][e];if(o>=0){let e=this.armors[t][o];this.budget-=~~((e.startingQuriousPoints+(e.fodderSkills.length?10:5))/3);for(let t=0;t<4;++t)this.decoSlotsResetValues[t]+=-e.decos[t]+n.decos[t];for(let t of e.requestedSkills)s.names.get(t)[3]+=e.skills[t]}else for(let t=0;t<4;++t)this.decoSlotsResetValues[t]+=n.decos[t];this.theseArmors[this.indexByType[n.type]]=n,this.budget+=~~((n.startingQuriousPoints+(n.fodderSkills.length?10:5))/3);for(let t of n.requestedSkills)(s.names.get(t)[3]-=n.skills[t])<0&&++i;return i}resetArmors(){for(let t=0;t<5;t++){let e=this.theseArmors[t];e.augsPointer=3,e.skillLen=e.len,e.skillsRemovedCount=-1,e.quriousPoints=e.startingQuriousPoints,e.unBloatedPoints=~~(e.startingQuriousPoints/3),e.initAugs[1]!==e.augs[1]&&(e.augs[1]=e.initAugs[1]),e.augs[2]!==e.initAugs[2]&&(e.augs[2]=e.initAugs[2])}}getPoints(t,e){if(!e){if(e=t.augsPointer,6===t.augsPointer)return;++t.augsPointer}let s=t.fodderSkills[++t.skillsRemovedCount];s?(t.augs[e]={"-Skill":s},t.quriousPoints+=10):(t.augs[e]=this.defAug,t.quriousPoints+=5),t.unBloatedPoints=~~(t.quriousPoints/3)}setAugmentRemovalOrder(){this.theseArmors.sort(((t,e)=>e.len-t.len||e.startingQuriousPoints-t.startingQuriousPoints));let t=this.theseArmors,e=0,s=4;for(let o=0;o<5;++o)this.indexByType[t[o].type]=o,t[o].decoAugs&&(this.augmentRemovalOrder[t[o].len>2?e++:s--]=t[o]);this.augmentRemovalOrder.splice(e,s-e+1)}removeUnusedSlotAugments(t){let s=0;for(let o of this.augmentRemovalOrder){if(!t[3]&&!t[1])break;let i=o.decoAugs,n=i.length-1,r=i[n],l=0,u=!0,a=o.len>2?1:0;t:for(;n>a;){if((t[l]-=i[n][l]-i[n-1][l])<0){for(;l>=0;)t[l]+=i[n][l]-i[n-1][l],--l;break t}4==++l&&(l=0,u=!1,--n)}if(u)continue;let f=i[n];if(0===n){e.getPoints(o,2);let t=o.augs[2]["-Def"]?5:10;s+=o.unBloatedPoints-~~((o.quriousPoints-t)/3)}else o.augs[2]={"+Slots":-f[5]};let c=r[5]-f[5];o.quriousPoints+=c,o.unBloatedPoints+=c/3,s+=c/3}return s+this.budget}addSkillToSet(t,e,s){let o=e.skillLen;for(;o--;)if(s[o]===t)return!0;return e.skillLen<5&&(s[e.skillLen++]=t,!0)}}function n(t,o,i){const n=o[0];let c=n.total;t:for(let e=0;e<5;e++){const s=t.theseArmors[e];if(c<=0)return n.pointer;let h=Math.min(3,i,c),d=3-h,m=s.skillLimitation,g=n.keys[n.pointer-1];for(;--d>=0&&s.unBloatedPoints<g;)t.getPoints(s);for(;h;)if(h>m){let e=1===m?a(h,s.unBloatedPoints,n,o,s):a(h-1,s.unBloatedPoints-n.keys[0],n,o,s);if(e){if(f(e[0],s,n,o[e[0][2]],e[1]))return!0;if(0==(c-=e[1]))return n.pointer;if(0==(h-=e[1]))continue t;continue}if(t.getPoints(s),! --h)continue t}else{let e=2===h?l(n,s.unBloatedPoints,o):3===h?r(n,s.unBloatedPoints,o):1===h?u(n,s.unBloatedPoints):0;if(e){for(;h--;){if(f(o[e[h]].skills[0],s,n,o[e[h]]))return!0;if(! --c)return n.pointer;if(!h)continue t}continue}if(t.getPoints(s),! --h)continue t}}return n.pointer&&4===i&&function(t,o){let i=s.costs;for(const s of e.theseArmors){if(!t||!o.pointer)break;let n=s.augsPointer;if(n<6&&s.unBloatedPoints<o.keys[0]||6===n&&s.quriousPoints<5+3*o.keys[0])continue;let r=0,l=0;for(let t=0;t<n;++t){let e=s.augs[t];e["-Def"]?r=t:e["-Skill"]&&(l=t)}let u=6-s.augsPointer?0:r?5:l?10:999;if(999===u||~~((s.quriousPoints-u)/3)<o.keys[0])continue;let a,c=o.keys.slice(0,o.pointer);t:for(let t of c){if(s.quriousPoints-u<3*t)continue;let o=i[t];for(let t=0;t<o.pointer;++t)if(e.addSkillToSet(o.skills[t][1],s,s.innateSkills)){a=o.skills[t];break t}}if(a&&(u&&(s.quriousPoints-=u,s.unBloatedPoints=~~(s.quriousPoints/3),s.augs.splice((r||l)-1,1),--s.augsPointer),!f(a,s,o,i[a[2]])&&! --t))return}}(c,n),n.pointer}function r(t,e,s){const o=t.pointer,i=t.keys;let n=o;for(;n--;){if(3*i[n]>e)continue;let t=o;for(;t-- >n;){if(i[n]+2*i[t]>e||s[i[n]].total<=(n===t))continue;let r=o;for(;r-- >t;)if((t===r||i[n]+i[t]+i[r]<=e)&&s[i[r]].total>(r===n)+(r===t))return[i[n],i[t],i[r]]}}}function l(t,e,s){const o=t.pointer,i=t.keys;let n=o,r=0;for(;n--;){if(r=i[n],r+r>e)continue;let t=o;for(;t-- >n;)if(n!==t&&r+i[t]<=e||n===t&&s[r].total>1)return[r,i[t]]}}function u(t,e){let s=t.pointer;for(;s--;)if(t.keys[s]<=e)return[t.keys[s]]}function a(t,e,o,i,n){let r=o.pointer,l=o.keys,u=e-o.keys[0]*(t-1);for(const t of n.requestedSkills)if(s.names.get(t)[0]>0&&s.names.get(t)[2]<=u)return[s.names.get(t),1];for(;r--;){let s=l[r],o=i[s];if(s*t<=e&&o.total-o.pointer>=t){let e=o.pointer;for(;e--;){let s=o.skills[e];if(s[0]>=t)return[s,t]}}}}function f(t,s,o,i,n=1){let r=t[1],l=t[2];if(s.unBloatedPoints<l*n||s.augsPointer+n>6||!e.addSkillToSet(r,s,s.innateSkills))return!0;s.quriousPoints-=3*l*n,s.unBloatedPoints-=l*n;for(let e=0;e<n;++e)s.augs[s.augsPointer++]=t[5];if(t[0]-=n,0==(i.total-=n)){if(i.skills.pop(),--i.pointer,o.keys[--o.pointer]===l)return;for(let t=0;t<o.pointer;++t)if(o.keys[t]===l){for(;t<o.pointer;)o.keys[t]=o.keys[++t];return}}if(t[0])return;let u=i.skills,a=--i.pointer;if(u[a]!==t)for(let e=0;e<a;++e)if(u[e]===t)return void(u[e]=u[a])}function c(t,e,o,i){let n=[],r=i[3];if(i[0]){let t=i[2]-r;if(t){let o=0;for(;o<e.pointer-1;){let r=e.arr[o++],l=e.arr[o++],u=e.arr[o++],a=e.arr[o++];const f=s.names.get(r)[2]-1;if(f<3)break;if(i[f]<l)continue;let c=Math.min(~~(t/l),a);n[u-1]<c&&(n[u-1]=c)}}}for(let e=0;e<4;++e)n[e]+=t[e];r&&(n[3]+=~~((r+n[1]+n[2])/2),n[1]+=r+n[1]+n[2],n[2]+=r,n[0]=i[1]);for(let t=0;t<4;++t)o[t]=Math.max(o[t],n[t])}function h(t,s){const o=[];t:for(let t of e.theseArmors){if(t.quriousPoints<(6===t.augsPointer?8:3)||t.skillLen>4)continue;let e=s,i=0,n=0;for(let s of t.augs)if(s["-Def"])++i;else if(s["-Skill"])++n;else if(s["+skill"]&&0==--e)continue t;let r=6-t.augsPointer,l=--r>=0?0:--i>=0?5:--n>=0?10:999;if(999===l)continue;let u=1;for(;t.quriousPoints>=l+3*u;){let s=Math.min(e,5,~~((t.quriousPoints-l)/u/3));for(;s--;)++o[s];if(l+=--r>=0?0:--i>=0?5:--n>=0?10:999,999===l)break;++u}}for(let e=0;e<5;e++)t[e]=Math.max(t[e],o[e]);return o}function d(t){for(let o of e.theseArmors){if(!o.fodderCount)continue;const e={...o.skills};for(const t of o.augs)t&&t["-Skill"]&&--e[t["-Skill"]];let i=0;for(let[t,o]of Object.entries(e))s.starting[t]&&(o-=s.starting[t]),o>0&&(i+=o);const n=i+(6-o.augsPointer)+~~(o.quriousPoints/5);if(n)for(let e=0;e<o.len;e++){let i=o.innateSkills[e],r=s.names.has(i)?-s.names.get(i)[0]:n;r&&(t[i]=Math.max(t[i]||0,Math.min(o.skills[i],r)))}}}"undefined"!=typeof self&&(self.onmessage=t=>{e=new i(t.data.armors,t.data.charmSlots),s=new o(t.data.skills);const{setLimiter:r,setBonus:l,charmNeeded:u}=t.data;t=null,function(t,o,i){const r={sets:[{armors:[],count:0,usedSkills:[{charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}]}],count:{sets:0,combos:0},stats:{quriousSkills:new Int8Array(5),armorSkills:{},remainingSlots:new Int8Array(4)},name:self.name};let l,u=r.sets[r.count.sets],a=u.usedSkills[u.count],f=a.decos;const m=new Int8Array(4);let g=[];const k=new Int8Array(2);let p=[],P=[];const y=s.charms;let S=0;t:for(;;){S=0;for(let t=0;t<5;t++){let s=e.indexes[t],o=s.index;if(++s.index===s.len&&(s.index=0,"leg"===s.type))break t;if(e.setNextArmor(s.type,s.index,o),0!==s.index)break}if(S)continue;if(o)for(const t in o)if(s.names.get(+t)[3]>0)continue t;if(i){g=[];for(let t of Object.keys(i))s.names.get(+t)[3]>0&&g.push(s.names.get(+t))}e.setAugmentRemovalOrder(),k[0]=0;e:for(let o=0,S=y.length;o<S;o++)if(p=y[o],!(p[0][3]<p[1][1])){p[0][3]-=p[1][1],k[1]=0;s:for(let A=0;A<S;A++){if(A===o)continue;if(P=y[A],P[0][3]<P[2][1])continue;if(P[0][3]-=P[2][1],i)for(let t of g)if(t[3]>0){P[0][3]+=P[2][1];continue s}for(let t=0;t<4;++t)m[t]=e.decoSlotsResetValues[t];e.resetArmors(),a.decos.pointer=s.useDecorationSlots(m,a.decos.arr);let S=e.removeUnusedSlotAugments(m);if(s.useDecosRound2(m,a.decos,S,5*t)||n(e,s.costs,t)){if(P[0][3]+=P[2][1],++k[1]<9)continue s;if(p[0][3]+=p[1][1],++k[0]<8)continue e;break e}!u.count&&r.stats.remainingSlots[3]<5&&r.stats.quriousSkills[4]<5&&(d(r.stats.armorSkills),h(r.stats.quriousSkills,t),c(m,f,r.stats.remainingSlots,r.stats.quriousSkills)),a.charms[0]=p[1],a.charms[1]=P[2];for(let t of e.theseArmors){l=a.armors[t.type];for(let e=0;e<6;e++)l[e]=e<t.augsPointer?t.augs[e]:null}++u.count,u.usedSkills[u.count]||(u.usedSkills[u.count]={charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}),a=u.usedSkills[u.count],f=a.decos,P[0][3]+=P[2][1]}p[0][3]+=p[1][1]}if(!u.count)continue;++r.count.sets,r.count.combos+=u.count;let A=r.sets.length-1;if(A&&r.sets[A-1].count<u.count){for(;A>0&&r.sets[A-1].count<u.count;)r.sets[A]=r.sets[--A];r.sets[A]=u}let b=Object.values(e.indexByType);for(let t=0;t<5;t++)u.armors[t]=e.theseArmors[b[t]].name;r.sets.length<6&&r.sets.push({armors:[],count:0,usedSkills:[{charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}]}),u=r.sets[r.sets.length-1],u.count=0,a=u.usedSkills[0],f=a.decos}if(1===r.sets.length)return void postMessage(!1);r.sets.pop(),r.sets.forEach((t=>{t.usedSkills.pop(),t.usedSkills.forEach((t=>{for(let e=t.decos.pointer;e<84;e++)t.decos.arr[e]=0;t.decos=t.decos.arr}))})),postMessage(r)}(r,l,u)})})();
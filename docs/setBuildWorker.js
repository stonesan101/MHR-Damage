(()=>{var t={121:(t,e,s)=>{s.d(e,{T:()=>o});class o{constructor(t,e){this.armors=t,this.augmentRemovalOrder=[0,1,2,3,4],this.indexes=["helm","chest","arm","waist","leg"].map((t=>({index:-1,len:this.armors[t].length,type:t}))),this.decoSlotsResetValues=new Int8Array(4);for(let t=0;t<4;t++)this.decoSlotsResetValues[t]=e[t];this.budget=4,this.indexByType={helm:0,chest:1,arm:2,waist:3,leg:4},this.defAug={"-Def":5},this.theseArmors=[],this.offsetTable=new Int8Array([0,0,0,0,0,0,0,0,0,0,1,3,4,6,7,9,11,13,15,18])}setNextArmor(t,e,s,o){let i=0,r=this.armors[t][e];if(s>=0){let e=this.armors[t][s];this.budget-=~~((e.startingQuriousPoints+(e.fodderSkills.length?10:5))/3);for(let t=0;t<4;++t)this.decoSlotsResetValues[t]+=-e.decos[t]+r.decos[t];for(let t of e.requestedSkills)o.get(t)[3]+=e.skills[t]}else for(let t=0;t<4;++t)this.decoSlotsResetValues[t]+=r.decos[t];this.theseArmors[this.indexByType[r.type]]=r,this.budget+=~~((r.startingQuriousPoints+(r.fodderSkills.length?10:5))/3);for(let t of r.requestedSkills)(o.get(t)[3]-=r.skills[t])<0&&++i;return i}resetArmors(){for(let t=0;t<5;t++){let e=this.theseArmors[t];e.augsPointer=3,e.skillLen=e.len,e.skillsRemovedCount=-1,e.quriousPoints=e.startingQuriousPoints,e.unBloatedPoints=~~(e.startingQuriousPoints/3),e.initAugs[1]!==e.augs[1]&&(e.augs[1]=e.initAugs[1]),e.augs[2]!==e.initAugs[2]&&(e.augs[2]=e.initAugs[2])}}getPoints(t,e){if(!e){if(e=t.augsPointer,6===t.augsPointer)return;++t.augsPointer}let s=t.fodderSkills[++t.skillsRemovedCount];s?(t.augs[e]={"-Skill":s},t.quriousPoints+=10):(t.augs[e]=this.defAug,t.quriousPoints+=5),t.unBloatedPoints=~~(t.quriousPoints/3)}setAugmentRemovalOrder(){this.theseArmors.sort(((t,e)=>e.len-t.len||e.startingQuriousPoints-t.startingQuriousPoints));let t=this.theseArmors,e=0,s=4;for(let o=0;o<5;++o)this.indexByType[t[o].type]=o,t[o].decoAugs&&(this.augmentRemovalOrder[t[o].len>2?e++:s--]=t[o]);this.augmentRemovalOrder.splice(e,s-e+1)}removeUnusedSlotAugments(t){let e=0;for(let s of this.augmentRemovalOrder){if(!t[3]&&!t[1])break;let o=s.decoAugs,i=o.length-1,r=o[i],n=0,l=!0,u=s.len>2?1:0;t:for(;i>u;){if((t[n]-=o[i][n]-o[i-1][n])<0){for(;n>=0;)t[n]+=o[i][n]-o[i-1][n],--n;break t}4==++n&&(n=0,l=!1,--i)}if(l)continue;let a=o[i];if(0===i){this.getPoints(s,2);let t=s.augs[2]["-Def"]?5:10;e+=s.unBloatedPoints-~~((s.quriousPoints-t)/3)}else s.augs[2]={"+Slots":-a[5]};let f=r[5]-a[5];s.quriousPoints+=f,s.unBloatedPoints+=f/3,e+=f/3}return e+this.budget}addSkillToSet(t,e,s){let o=e.skillLen;for(;o--;)if(s[o]===t)return!0;return e.skillLen<5&&(s[e.skillLen++]=t,!0)}}},166:(t,e,s)=>{var o=s(121),i=s(580);let r,n;function l(t,e,s){const o=e[0];let i=o.total;t:for(let r=0;r<5;r++){const n=t.theseArmors[r];if(i<=0)return o.pointer;let l=Math.min(3,s,i),d=n.skillLimitation;if(l<3){let e=3-l,s=o.getHighestCost()*l;for(;e--&&n.unBloatedPoints<s;)t.getPoints(n)}for(;l;)if(l>d){let s=1===d?c(l,n.unBloatedPoints,o,e,n):c(l-1,n.unBloatedPoints-o.keys[0],o,e,n);if(s){if(h(s[0],n,o,e[s[0][2]],s[1]))return!0;if(0==(i-=s[1]))return o.pointer;if(0==(l-=s[1]))continue t;continue}if(t.getPoints(n),! --l)continue t}else{let s=2===l?a(o,n.unBloatedPoints,e):3===l?u(o,n.unBloatedPoints,e):1===l?f(o,n.unBloatedPoints):0;if(s){for(;l--;){if(h(e[s[l]].skills[0],n,o,e[s[l]]))return!0;if(! --i)return o.pointer;if(!l)continue t}continue}if(0==--l)continue t;t.getPoints(n)}}return o.pointer&&4===s&&function(t,e){let s=n.costs;for(const o of r.theseArmors){if(!t||!e.pointer)break;let i=o.augsPointer;if(i<6&&o.unBloatedPoints<e.keys[0]||6===i&&o.quriousPoints<5+3*e.keys[0])continue;let n=0,l=0;for(let t=0;t<i;++t){let e=o.augs[t];e["-Def"]?n=t:e["-Skill"]&&(l=t)}let u=6-o.augsPointer?0:n?5:l?10:999;if(999===u||~~((o.quriousPoints-u)/3)<e.keys[0])continue;let a,f=e.keys.slice(0,e.pointer);t:for(let t of f){if(o.quriousPoints-u<3*t)continue;let e=s[t];for(let t=0;t<e.pointer;++t)if(r.addSkillToSet(e.skills[t][1],o,o.innateSkills)){a=e.skills[t];break t}}if(a&&(u&&(o.quriousPoints-=u,o.unBloatedPoints=~~(o.quriousPoints/3),o.augs.splice((n||l)-1,1),--o.augsPointer),!h(a,o,e,s[a[2]])&&! --t))return}}(i,o),o.pointer}function u(t,e,s){const o=t.pointer,i=t.keys;let r=o;for(;r--;){if(3*i[r]>e)continue;let t=o;for(;t-- >r;){if(i[r]+2*i[t]>e||s[i[r]].total<=(r===t))continue;let n=o;for(;n-- >t;)if((t===n||i[r]+i[t]+i[n]<=e)&&s[i[n]].total>(n===r)+(n===t))return[i[r],i[t],i[n]]}}}function a(t,e,s){const o=t.pointer,i=t.keys;let r=o,n=0;for(;r--;){if(n=i[r],n+n>e)continue;let t=o;for(;t-- >r;)if(r!==t&&n+i[t]<=e||r===t&&s[n].total>1)return[n,i[t]]}}function f(t,e){let s=t.pointer;for(;s--;)if(t.keys[s]<=e)return[t.keys[s]]}function c(t,e,s,o,i){let r=s.pointer,l=s.keys,u=e-s.keys[0]*(t-1);for(const t of i.requestedSkills)if(n.names.get(t)[0]>0&&n.names.get(t)[2]<=u)return[n.names.get(t),1];for(;r--;){let s=l[r],i=o[s];if(s*t<=e&&i.total-i.pointer>=t){let e=i.pointer;for(;e--;){let s=i.skills[e];if(s[0]>=t)return[s,t]}}}}function h(t,e,s,o,i=1){let n=t[1],l=t[2];if(e.unBloatedPoints<l*i||e.augsPointer+i>6||!r.addSkillToSet(n,e,e.innateSkills))return!0;e.quriousPoints-=3*l*i,e.unBloatedPoints-=l*i;for(let s=0;s<i;++s)e.augs[e.augsPointer++]=t[5];if(t[0]-=i,0!=(o.total-=i)){if(!t[0]){let e=o.skills,s=--o.pointer;if(e[s]===t)return;for(let o=0;o<s;++o)if(e[o]===t)return void(e[o]=e[s])}}else{if(o.skills.pop(),--o.pointer,s.keys[--s.pointer]===l)return;s.removeCost(l)}}function d(t,e,s,o){let i=[],r=o[3];if(o[0]){let t=o[2]-r;if(t){let s=0;for(;s<e.pointer-1;){let r=e.arr[s++],l=e.arr[s++],u=e.arr[s++],a=e.arr[s++];const f=n.names.get(r)[2]-1;if(f<3)break;if(o[f]<l)continue;let c=Math.min(~~(t/l),a);i[u-1]<c&&(i[u-1]=c)}}}for(let e=0;e<4;++e)i[e]+=t[e];r&&(i[3]+=~~((r+i[1]+i[2])/2),i[1]+=r+i[1]+i[2],i[2]+=r,i[0]=o[1]);for(let t=0;t<4;++t)s[t]=Math.max(s[t],i[t])}function g(t,e){if(0===e)return t;const s=[0,0,0,0];t:for(let t of r.theseArmors){if(t.quriousPoints<(6===t.augsPointer?8:3)||t.skillLen>4)continue;let o=e,i=0,r=0;for(let e of t.augs)if(e["-Def"])++i;else if(e["-Skill"])++r;else if(e["+Skill"]&&0==--o)continue t;let n=6-t.augsPointer,l=--n>=0?0:--i>=0?5:--r>=0?10:999;if(999===l)continue;let u=1;for(;t.quriousPoints>=l+3*u;){let e=Math.min(o,5,~~((t.quriousPoints-l)/u/3));for(;e--;)++s[e];if(l+=--n>=0?0:--i>=0?5:--r>=0?10:999,999===l)break;++u}}for(let e=0;e<5;e++)t[e]=Math.max(t[e],s[e]);return t}function m(t){let e={};for(let t of r.theseArmors){if(!t.fodderCount)continue;const s={...t.skills};for(let e=0;e<t.augsPointer;e++){const o=t.augs[e];o["-Skill"]&&--s[o["-Skill"]]}let o=0;for(let e=0;e<t.len;e++){const i=t.innateSkills[e];n.starting[i]?n.starting[i]<s[i]&&(o+=s[i]-(n.starting[i]||0)):o+=s[i]}const i=o+(6-t.augsPointer)+~~(t.quriousPoints/5);if(i)for(let s=0;s<t.len;s++){let o=t.innateSkills[s],r=n.names.has(o)?-n.names.get(o)[0]:i;r&&(e[o]=(e[o]||0)+Math.min(t.skills[o],r))}}let s=Object.entries(e);for(let e=0;e<s.length;e++)t[s[e][0]]>=s[e][1]||(t[s[e][0]]=s[e][1])}"undefined"!=typeof self&&(self.onmessage=t=>{r=new o.T(t.data.armors,t.data.charmSlots),n=new i.c(t.data.skills,t.data.charmLevels);const{setLimiter:e,setBonus:s,charmNeeded:u}=t.data;t=null,function(t,e,s){const o={sets:[{armors:[],count:0,usedSkills:[{charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}]}],count:{sets:0,combos:0},stats:{quriousSkills:new Int8Array(5),armorSkills:{},remainingSlots:new Int8Array(4)},name:self.name};let i,u=o.sets[o.count.sets],a=u.usedSkills[u.count],f=a.decos;const c=new Int8Array(4);let h=[];const k=new Int8Array(2);let p=[],P=[];const y=n.charms;let S=0;t:for(;;){S=0;for(let t=0;t<5;t++){let e=r.indexes[t],s=e.index;if(++e.index===e.len&&(e.index=0,"leg"===e.type))break t;if(r.setNextArmor(e.type,e.index,s,n.names),0!==e.index)break}if(S)continue;if(e)for(const t in e)if(n.names.get(+t)[3]>0)continue t;if(s){h=[];for(let t of Object.keys(s))n.names.get(+t)[3]>0&&h.push(n.names.get(+t))}r.setAugmentRemovalOrder(),k[0]=0;e:for(let e=0,S=y.length;e<S;e++)if(p=y[e],!(p[0][3]<p[1][1])){p[0][3]-=p[1][1],k[1]=0;s:for(let v=0;v<S;v++){if(v===e)continue;if(P=y[v],P[0][3]<P[2][1])continue;if(P[0][3]-=P[2][1],s)for(let t of h)if(t[3]>0){P[0][3]+=P[2][1];continue s}for(let t=0;t<4;++t)c[t]=r.decoSlotsResetValues[t];r.resetArmors(),a.decos.pointer=n.useDecorationSlots(c,a.decos.arr);let S=r.removeUnusedSlotAugments(c);if(n.useDecosRound2(c,a.decos,S,5*t,r.offsetTable)||l(r,n.costs,t)){if(P[0][3]+=P[2][1],++k[1]<9)continue s;if(p[0][3]+=p[1][1],++k[0]<5)continue e;break e}k[1]=0,k[0]=0,!u.count&&o.stats.remainingSlots[3]<5&&o.stats.quriousSkills[4]<5&&(m(o.stats.armorSkills),g(o.stats.quriousSkills,t),d(c,f,o.stats.remainingSlots,o.stats.quriousSkills)),a.charms[0]=p[1],a.charms[1]=P[2];for(let t of r.theseArmors){i=a.armors[t.type];for(let e=0;e<6;e++)i[e]=e<t.augsPointer?t.augs[e]:null}++u.count,u.usedSkills[u.count]||(u.usedSkills[u.count]={charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}),a=u.usedSkills[u.count],f=a.decos,P[0][3]+=P[2][1]}p[0][3]+=p[1][1]}if(!u.count)continue;++o.count.sets,o.count.combos+=u.count;let v=o.sets.length-1;if(v&&o.sets[v-1].count<u.count){for(;v>0&&o.sets[v-1].count<u.count;)o.sets[v]=o.sets[--v];o.sets[v]=u}let A=Object.values(r.indexByType);for(let t=0;t<5;t++)u.armors[t]=r.theseArmors[A[t]].name;o.sets.length<6&&o.sets.push({armors:[],count:0,usedSkills:[{charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}]}),u=o.sets[o.sets.length-1],u.count=0,a=u.usedSkills[0],f=a.decos}if(1===o.sets.length)return void postMessage(!1);o.sets.pop(),o.sets.forEach((t=>{t.usedSkills.pop(),t.usedSkills.forEach((t=>{for(let e=t.decos.pointer;e<84;e++)t.decos.arr[e]=0;t.decos=t.decos.arr}))})),postMessage(o)}(e,s,u)})},580:(t,e,s)=>{s.d(e,{c:()=>o});class o{constructor(t,e){this.arrs=t.reverse(),this.len=t.length,this.names=new Map,this.charms=e,this.previousObj={total:0},this.previousCost=0,this.round2=[],this.round2Pointer=0,this.starting={};let s=this.len;for(this.costKeys={total:0,keys:new Int8Array(5),pointer:0,getHighestCost:()=>this.costKeys.keys[this.costKeys.pointer-1],reverseArrays:(t,e)=>{let s=-1,o=0;for(;++s<--t;)o=e[t],e[t]=e[s],e[s]=o},removeCost:t=>{const e=this.costKeys;for(let s=0;s<e.pointer;++s)if(e.keys[s]===t){for(;s<e.pointer;)e.keys[s]=e.keys[++s];return}}},this.costs=[this.costKeys,{total:1,skills:[],pointer:0},{total:2,skills:[],pointer:0},{total:1,skills:[],pointer:0},{total:1,skills:[],pointer:0},{total:3,skills:[],pointer:0}];s--;){let t=this.arrs[s];this.names.set(t[1],t),this.starting[t[1]]=t[3]}}useDecorationSlots(t,e){this.round2Pointer=0;let s,o,i,r=this.len,n=this.arrs,l=0,u=0,a=0,f=0,c=0,h=0;t:for(;r--;)if(s=n[r],!((s[0]=s[3])<=0)){if(i=s[4],c=Math.min(i.length,4),s[6]&&t[i[0]]&&i[1]<=s[0])h=0;else{if(!(c>2&&t[i[2]])){this.round2[this.round2Pointer++]=s;continue t}h=2}for(o=s[1];h<c;)if(u=i[h++],a=i[h++],!(s[0]<a)&&(f=Math.min(~~(s[0]/a),t[u]),f>0&&(e[l++]=o,e[l++]=a,e[l++]=u,e[l++]=f,t[u]-=f,0==(s[0]-=f*a))))continue t;this.round2[this.round2Pointer++]=s}return l}useDecosRound2(t,e,s,o,i){this.costKeys.pointer=1;let r=0;this.previousCost=0;let n,l,u=e.pointer,a=e.arr,f=this.round2,c=0,h=0,d=0,g=0,m=0,k=0,p=-1;t:for(;++p<this.round2Pointer;){for(n=f[p],l=n[4],c=l.length,h=!c||t[l[0]]?0:c<4||t[l[2]]?2:c<6||t[l[4]]?4:c;h<c;)if(d=l[h++],g=l[h++],t[d]&&(m=Math.max(1,Math.min(~~(n[0]/g),t[d])),t[d]-=m,a[u++]=n[1],a[u++]=g,a[u++]=d,a[u++]=m,(n[0]-=m*g)<=0))continue t;if((r+=n[0])>o||(s-=n[0]*n[2])<i[r]||!n[2])return!0;this.previousCost===n[2]?(this.previousObj.total+=n[0],this.previousObj.skills[this.previousObj.pointer++]=n):(this.previousCost=n[2],this.costKeys.keys[k++]=this.previousCost,this.previousObj=this.costs[this.previousCost],this.previousObj.pointer=1,this.previousObj.total=n[0],this.previousObj.skills[0]=n)}k>1&&(this.costKeys.pointer=k,this.costKeys.reverseArrays(k,this.costKeys.keys)),this.costKeys.total=r,e.pointer=u}}}},e={};function s(o){var i=e[o];if(void 0!==i)return i.exports;var r=e[o]={exports:{}};return t[o](r,r.exports,s),r.exports}s.d=(t,e)=>{for(var o in e)s.o(e,o)&&!s.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),s(166),s(580);s(121)})();
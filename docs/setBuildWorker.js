(()=>{var t={};let e,s;t.d=(e,s)=>{for(var o in s)t.o(s,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:s[o]})},t.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);class o{constructor(t){this.arrs=t.reverse(),this.len=t.length,this.names=new Map,this.charms=[],this.previousObj={total:0},this.previousCost=0,this.round2=[],this.round2Pointer=0,this.starting={};let e=this.len;for(this.costs=[{total:0,keys:[],pointer:0},{total:1,skills:[],pointer:0},{total:2,skills:[],pointer:0},{total:1,skills:[],pointer:0},{total:1,skills:[],pointer:0},{total:3,skills:[],pointer:0}],this.costKeys=this.costs[0];e--;){let t=this.arrs[e];this.names.set(t[1],t),this.starting[t[1]]=t[3];let s=t.pop();s&&(s[0]=t,this.charms.push(s)),t[6]=t[4]&&1!==t[4][1]?0:2}}useDecorationSlots(t,e){let s,o,i=0,r=0,n=0;this.round2Pointer=0;let l=0,u=0,a=this.len,f=this.arrs;t:for(;a--;)if(s=f[a],!((s[0]=s[3])<=0)){if(o=s[4],l=Math.min(o.length,4),!l||!s[6]&&t[3])u=0;else{if(2!==l&&!t[o[2]]){this.round2[this.round2Pointer++]=s;continue t}u=2}for(;u<l;){if(r=o[u++],n=o[u++],s[0]<n)continue;let l=Math.min(~~(s[0]/n),t[r]);if(l>0&&(e[i++]=s[1],e[i++]=n,e[i++]=r,e[i++]=l,t[r]-=l,0==(s[0]-=l*n)))continue t}this.round2[this.round2Pointer++]=s}return i}useDecosRound2(t,s,o,i){this.costKeys.pointer=0;let r=0;this.previousCost=0;let n,l,u=e.offsetTable,a=s.pointer,f=s.arr,c=this.round2,h=0,d=0,m=0,g=0,k=0,p=-1;t:for(;++p<this.round2Pointer;){for(n=c[p],l=n[4],g=l.length,k=!g||t[3]?0:2===g||t[l[2]]?2:4===g||t[l[4]]?4:g;k<g;)if(h=l[k++],d=l[k++],t[h]&&(m=Math.max(1,Math.min(~~(n[0]/d),t[h])),f[a++]=n[1],f[a++]=d,f[a++]=h,f[a++]=m,t[h]-=m,(n[0]-=m*d)<=0))continue t;if((r+=n[0])>i||(o-=n[0]*n[2])-u[r]<0||!n[2])return!0;this.previousCost===n[2]?(this.previousObj.total+=n[0],this.previousObj.skills[this.previousObj.pointer++]=n):(this.previousCost=n[2],this.costKeys.keys[this.costKeys.pointer++]=this.previousCost,this.previousObj=this.costs[this.previousCost],this.previousObj.pointer=1,this.previousObj.total=n[0],this.previousObj.skills[0]=n)}this.costKeys.pointer>1&&(this.costKeys.keys.length>this.costKeys.pointer&&this.costKeys.keys.splice(this.costKeys.pointer,1/0),this.costKeys.keys.reverse()),this.costKeys.total=r,s.pointer=a}}class i{constructor(t,e){this.armors=t,this.augmentRemovalOrder=[0,1,2,3,4],this.indexes=["helm","chest","arm","waist","leg"].map((t=>({index:-1,len:this.armors[t].length,type:t}))),this.decoSlotsResetValues=new Int8Array(4);for(let t=0;t<4;t++)this.decoSlotsResetValues[t]=e[t];this.budget=4,this.indexByType={helm:0,chest:1,arm:2,waist:3,leg:4},this.defAug={"-Def":5},this.theseArmors=[],this.offsetTable=new Int8Array([0,0,0,0,0,0,0,0,0,0,1,3,4,6,7,9,11,13,15,18])}setNextArmor(t,e,o){let i=0,r=this.armors[t][e];if(o>=0){let e=this.armors[t][o];this.budget-=~~((e.startingQuriousPoints+(e.fodderSkills.length?10:5))/3);for(let t=0;t<4;++t)this.decoSlotsResetValues[t]+=-e.decos[t]+r.decos[t];for(let t of e.requestedSkills)s.names.get(t)[3]+=e.skills[t]}else for(let t=0;t<4;++t)this.decoSlotsResetValues[t]+=r.decos[t];this.theseArmors[this.indexByType[r.type]]=r,this.budget+=~~((r.startingQuriousPoints+(r.fodderSkills.length?10:5))/3);for(let t of r.requestedSkills)(s.names.get(t)[3]-=r.skills[t])<0&&++i;return i}resetArmors(){for(const t of this.theseArmors)t.augsPointer=3,t.skillLen=t.len,t.skillsRemovedCount=-1,t.quriousPoints=t.startingQuriousPoints,t.unBloatedPoints=~~(t.startingQuriousPoints/3),t.initAugs[1]!==t.augs[1]&&(t.augs[1]=t.initAugs[1]),t.augs[2]!==t.initAugs[2]&&(t.augs[2]=t.initAugs[2])}getPoints(t,e){if(!e){if(e=t.augsPointer,6===t.augsPointer)return;++t.augsPointer}let s=t.fodderSkills[++t.skillsRemovedCount];s?(t.augs[e]={"-Skill":s},t.quriousPoints+=10):(t.augs[e]=this.defAug,t.quriousPoints+=5),t.unBloatedPoints=~~(t.quriousPoints/3)}setAugmentRemovalOrder(){this.theseArmors.sort(((t,e)=>e.len-t.len||e.startingQuriousPoints-t.startingQuriousPoints));let t=this.theseArmors,e=0,s=4;for(let o=0;o<5;++o)this.indexByType[t[o].type]=o,t[o].decoAugs&&(this.augmentRemovalOrder[t[o].len<3?e++:s--]=t[o]);this.augmentRemovalOrder.splice(e,s-e+1)}removeUnusedSlotAugments(t){let s=0;for(let o of this.augmentRemovalOrder){if(!t[3]&&!t[1])break;let i=o.decoAugs,r=i.length-1,n=i[r],l=0,u=!0,a=o.len>2?1:0;t:for(;r>a;){if((t[l]-=i[r][l]-i[r-1][l])<0){for(;l>=0;)t[l]+=i[r][l]-i[r-1][l],--l;break t}4==++l&&(l=0,u=!1,--r)}if(u)continue;let f=i[r];if(0===r){e.getPoints(o,2);let t=o.augs[2]["-Def"]?5:10;s+=o.unBloatedPoints-~~((o.quriousPoints-t)/3)}else o.augs[2]={"+Slots":-f[5]};let c=n[5]-f[5];o.quriousPoints+=c,o.unBloatedPoints+=c/3,s+=c/3}return s+this.budget}addSkillToSet(t,e,s){let o=e.skillLen;for(;o--;)if(s[o]===t)return!0;return e.skillLen<5&&(s[e.skillLen++]=t,!0)}}function r(t,o,i){const r=o[0];let c=r.total;t:for(let e=0;e<5;e++){const s=t.theseArmors[e];if(c<=0)return r.pointer;let h=i>2?3:i,d=s.skillLimitation;for(;h>c;)t.getPoints(s),--h;for(;h;)if(h>d){let e=1===d?a(h,s.unBloatedPoints,r,o,s):a(h-1,s.unBloatedPoints-r.keys[0],r,o,s);if(e){if(f(e[0],s,r,o[e[0][2]],e[1]))return!0;if(0==(c-=e[1]))return r.pointer;if(0==(h-=e[1]))continue t;continue}if(t.getPoints(s),! --h)continue t}else{let e=2===h?l(r,s.unBloatedPoints,o):3===h?n(r,s.unBloatedPoints,o):1===h?u(r,s.unBloatedPoints):0;if(e){for(;h--;){if(f(o[e[h]].skills[0],s,r,o[e[h]]))return!0;if(! --c)return r.pointer;if(!h)continue t}continue}if(t.getPoints(s),! --h)continue t}}return r.pointer&&4===i&&function(t,o){let i=s.costs;for(const s of e.theseArmors){if(!t||!o.pointer)break;let r=s.augsPointer;if(r<6&&s.unBloatedPoints<o.keys[0]||6===r&&s.quriousPoints<5+3*o.keys[0])continue;let n=0,l=0;for(let t=0;t<r;++t){let e=s.augs[t];e["-Def"]?n=t:e["-Skill"]&&(l=t)}let u=6-s.augsPointer?0:n?5:l?10:999;if(999===u||~~((s.quriousPoints-u)/3)<o.keys[0])continue;let a,c=o.keys.slice(0,o.pointer);t:for(let t of c){if(s.quriousPoints-u<3*t)continue;let o=i[t];for(let t=0;t<o.pointer;++t)if(e.addSkillToSet(o.skills[t][1],s,s.innateSkills)){a=o.skills[t];break t}}if(a&&(u&&(s.quriousPoints-=u,s.unBloatedPoints=~~(s.quriousPoints/3),s.augs.splice((n||l)-1,1),--s.augsPointer),!f(a,s,o,i[a[2]])&&! --t))return}}(c,r),r.pointer}function n(t,e,s){const o=t.pointer,i=t.keys;let r=o;for(;r--;){if(3*i[r]>e)continue;let t=o;for(;t-- >r;){if(i[r]+2*i[t]>e||s[i[r]].total<=(r===t))continue;let n=o;for(;n-- >t;)if((t===n||i[r]+i[t]+i[n]<=e)&&s[i[n]].total>(n===r)+(n===t))return[i[r],i[t],i[n]]}}}function l(t,e,s){const o=t.pointer,i=t.keys;let r=o,n=0;for(;r--;){if(n=i[r],n+n>e)continue;let t=o;for(;t-- >r;)if(r!==t&&n+i[t]<=e||r===t&&s[n].total>1)return[n,i[t]]}}function u(t,e){let s=t.pointer;for(;s--;)if(t.keys[s]<=e)return[t.keys[s]]}function a(t,e,o,i,r){let n=o.pointer,l=o.keys,u=e-o.keys[0]*(t-1);for(const t of r.requestedSkills)if(s.names.get(t)[0]>0&&s.names.get(t)[2]<=u)return[s.names.get(t),1];for(;n--;){let s=l[n],o=i[s];if(s*t<=e&&o.total-o.pointer>=t-1){let e=o.pointer;for(;e--;){let s=o.skills[e];if(s[0]>=t)return[s,t]}}}}function f(t,s,o,i,r=1){let n=t[1],l=t[2];if(s.unBloatedPoints<l*r||s.augsPointer+r>6||!e.addSkillToSet(n,s,s.innateSkills))return!0;s.quriousPoints-=3*l*r,s.unBloatedPoints-=l*r;for(let t=0;t<r;++t)s.augs[s.augsPointer++]={"+Skill":n};if(t[0]-=r,0==(i.total-=r)){i.skills.pop(),--i.pointer;let t=--o.pointer;if(o.keys[t]===l)return!1;for(;--t;)if(o.keys[t]===l)return o.keys.splice(t,1),!1;return o.keys.shift(),!1}if(t[0])return!1;let u=i.skills,a=--i.pointer;if(u[a]===t)return!1;for(let e=0;e<a;++e)if(u[e]===t)return void(u[e]=u[a]);return!1}function c(t,e,o,i){let r=new Int8Array(4),n=i[3];if(i[0]){let t=i[2]-n;if(t){let o=0;for(;o<e.pointer-1;){let n=e.arr[o++],l=e.arr[o++],u=e.arr[o++],a=e.arr[o++];const f=s.names.get(n)[2]-1;if(f<3)break;if(i[f]<l)continue;let c=Math.min(~~(t/l),a);r[u-1]<c&&(r[u-1]=c)}}}for(let e=0;e<4;++e)r[e]+=t[e];n&&(r[3]+=~~((n+r[1]+r[2])/2),r[1]+=n+r[1]+r[2],r[2]+=n,r[0]=i[1]);for(let t=0;t<4;++t)o[t]=Math.max(o[t],r[t])}function h(t){const s=new Int8Array(5);for(let t of e.theseArmors){if(t.quriousPoints<(6===t.augsPointer?8:3)||t.skillLen>4)continue;let e=0,o=0;for(let s of t.augs)s["-Def"]?++e:s["-Skill"]&&++o;let i=6-t.augsPointer,r=--i>=0?0:--e>=0?5:--o>=0?10:999;if(999===r)continue;let n=1;for(;t.quriousPoints>=r+3*n;){let l=Math.min(5,~~((t.quriousPoints-r)/n/3));for(;l--;)++s[l];if(r+=--i>=0?0:--e>=0?5:--o>=0?10:999,999===r)break;++n}}for(let e=0;e<5;e++)t[e]=Math.max(t[e],s[e]);return s}function d(t){for(let o of e.theseArmors){if(!o.fodderCount||o.quriousPoints<5&&6===o.augsPointer)continue;const e=o.fodderCount-(o.skillsRemovedCount+3),i=6-o.augsPointer,r=Math.min(i+~~(o.quriousPoints/5),o.fodderCount);if(r)for(let i=0;i<o.len;i++){let n=o.innateSkills[i];e||!s.names.has(n)||s.names.get(n)[6]<0&&s.starting[n]<=o.skills[n]||(t[n]=Math.max(t[n]||0,Math.min(o.skills[n],r)))}}}"undefined"!=typeof self&&(self.onmessage=t=>{e=new i(t.data.armors,t.data.charmSlots),s=new o(t.data.skills);const{setLimiter:n,setBonus:l,charmNeeded:u}=t.data;t=null,postMessage(function(t,o,i){const n={sets:[{armors:[],count:0,usedSkills:[{charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}]}],count:{sets:0,combos:0},stats:{quriousSkills:new Int8Array(5),armorSkills:{},remainingSlots:new Int8Array(4)},name:self.name};let l=n.sets[n.count.sets],u=l.usedSkills[l.count],a=u.decos;const f=new Int8Array(4);let m=[];const g=new Int8Array(2);let k=[],p=[];const P=s.charms;let y=0;t:for(;;){y=0;for(let t of e.indexes){let s=t.index;if(++t.index===t.len&&(t.index=0,"leg"===t.type))break t;if(e.setNextArmor(t.type,t.index,s),0!==t.index)break}if(y)continue;if(o)for(const t in o)if(s.names.get(+t)[3]>0)continue t;if(i){m=[];for(let t of Object.keys(i))s.names.get(+t)[3]>0&&m.push(s.names.get(+t))}e.setAugmentRemovalOrder(),g[0]=0;e:for(let o=0,y=P.length;o<y;o++)if(k=P[o],!(k[0][3]<k[1][1])){k[0][3]-=k[1][1],g[1]=0;s:for(let S=0;S<y;S++){if(S===o)continue;if(p=P[S],p[0][3]<p[2][1])continue;if(p[0][3]-=p[2][1],i)for(let t of m)if(t[3]>0){p[0][3]+=p[2][1];continue s}for(let t=0;t<4;++t)f[t]=e.decoSlotsResetValues[t];e.resetArmors(),u.decos.pointer=s.useDecorationSlots(f,u.decos.arr);let y=e.removeUnusedSlotAugments(f);if(s.useDecosRound2(f,u.decos,y,t)||r(e,s.costs,t)){if(p[0][3]+=p[2][1],++g[1]<9)continue s;if(k[0][3]+=k[1][1],++g[0]<8)continue e;break e}!l.count&&n.stats.remainingSlots[3]<5&&n.stats.quriousSkills[4]<5&&(d(n.stats.armorSkills),h(n.stats.quriousSkills),c(f,a,n.stats.remainingSlots,n.stats.quriousSkills)),u.charms[0]=k[1],u.charms[1]=p[2];for(let t of e.theseArmors){let e=u.armors[t.type];for(let s=0;s<t.augsPointer;s++)e[s]=t.augs[s]}++l.count,l.usedSkills[l.count]||(l.usedSkills[l.count]={charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}),u=l.usedSkills[l.count],a=u.decos,p[0][3]+=p[2][1]}k[0][3]+=k[1][1]}if(!l.count)continue;++n.count.sets,n.count.combos+=l.count;let S=n.sets.length-1;if(S&&n.sets[S-1].count<l.count){for(;S>0&&n.sets[S-1].count<l.count;)n.sets[S]=n.sets[--S];n.sets[S]=l}let A=Object.values(e.indexByType);for(let t=0;t<5;t++)l.armors[t]=e.theseArmors[A[t]].name;n.sets.length<6&&n.sets.push({armors:[],count:0,usedSkills:[{charms:[],decos:{arr:new Uint8Array(84),pointer:0},armors:{helm:[],chest:[],arm:[],waist:[],leg:[]}}]}),l=n.sets[n.sets.length-1],l.count=0,u=l.usedSkills[0],a=u.decos}if(1===n.sets.length)return;return n.sets.pop(),n.sets.forEach((t=>{t.usedSkills.pop(),t.usedSkills.forEach((t=>{for(let e=t.decos.pointer;e<84;e++)t.decos.arr[e]=0;t.decos=t.decos.arr}))})),n}(5*n,l,u)),s=null,e=null})})();